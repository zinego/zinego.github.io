<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto+Serif+SC:300,300italic,400,400italic,700,700italic%7CPT+Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"yoursite.com","root":"/","images":"/images","scheme":"Muse","darkmode":true,"version":"8.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta property="og:type" content="website">
<meta property="og:title" content="zinego&#39;s blog">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="zinego&#39;s blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="zinego">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://yoursite.com/page/3/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/3/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>zinego's blog</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">zinego's blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="zinego"
      src="/images/default.png">
  <p class="site-author-name" itemprop="name">zinego</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">31</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/zinego" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/14/APUE-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%87%E5%87%86I-O%E5%BA%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/default.png">
      <meta itemprop="name" content="zinego">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zinego's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/02/14/APUE-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%87%E5%87%86I-O%E5%BA%93/" class="post-title-link" itemprop="url">APUE 阅读笔记 第五章 标准I/O库</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-02-14 11:19:18" itemprop="dateCreated datePublished" datetime="2019-02-14T11:19:18+08:00">2019-02-14</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-31 13:59:30" itemprop="dateModified" datetime="2021-10-31T13:59:30+08:00">2021-10-31</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/APUE%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">APUE阅读笔记</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>9.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>8 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="第五章-标准I-O库"><a href="#第五章-标准I-O库" class="headerlink" title="第五章 标准I/O库"></a>第五章 标准I/O库</h2><h3 id="5-1-引言"><a href="#5-1-引言" class="headerlink" title="5.1 引言"></a>5.1 引言</h3><pre><code>不仅是UNIX, 很多其他操作系统都实现了标准I/O库, 所以这个库由ISO C标准说明
</code></pre>
<h3 id="5-2-流和FILE对象"><a href="#5-2-流和FILE对象" class="headerlink" title="5.2 流和FILE对象"></a>5.2 流和FILE对象</h3><pre><code>在第三章中, 所有I/O函数都是围绕文件描述符的. 
当打开一个文件, 返回一个文件描述符, 然后该文件描述符就用于后续的I/O操作.
在标准I/O中, 他们的操作围绕流进行
流的定向决定了所读写的字符是单字节还是多字节的.
当一个流被创建的时候, 并没有被定向.
如果在为定向的流上使用一个`多字节的I/O函数`, 则该流定向设置为`宽定向`的.
如果在为定向的流上使用一个`单字节的I/O函数`, 则该流定向设置为`字节定向`的.
只有两个函数可以改变流的定向, freopen函数清除一个流的定向, fwide函数可用于设置流的定向
</code></pre>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wchar.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fwide</span><span class="params">(FILE *fp, <span class="keyword">int</span> mode)</span></span>;</span><br></pre></td></tr></table></figure>

<pre><code>1. 如果mode参数值为负, fwide将试图使指定的流是字节定向的.
2. 如果mode参数值为正, fwide将试图使指定的流是宽定向的.
3. 如果mode参数值是0, fwide将不试图设置流的定向, 但返回标识该流定向的值

fwide并不改变已经定向的流的定向, 此时fwide无错误返回. 
当打开一个流的时候, 标准I/O函数fopen返回一个指向FILE对象的指针. 该对象通常是一个结构
包含以下信息: 
    1. 实际I/O的文件描述符
    2. 指向用于该流缓冲区的指针
    3. 缓冲区的长度
    4. 当前在缓冲区的字节数
    5. 出错标志
</code></pre>
<h3 id="5-3-标准输入-标准输出和标准错误"><a href="#5-3-标准输入-标准输出和标准错误" class="headerlink" title="5.3 标准输入/标准输出和标准错误"></a>5.3 标准输入/标准输出和标准错误</h3><pre><code>对一个进程预定义了三个流, 标准输入, 标准输出和标准错误. 
stdin, stdout, stderr分别与STDIN_FILENO, STDOUT_FILENO, STDERR_FILENO对应
</code></pre>
<h3 id="5-4-缓冲"><a href="#5-4-缓冲" class="headerlink" title="5.4 缓冲"></a>5.4 缓冲</h3><pre><code>标准I/O提供缓冲的目的是尽可能减少使用read和write调用的次数.
也对每个I/O流进行自动的缓冲管理, 避免了应用程序需要考虑这一点所带来的麻烦
</code></pre>
<hr>
<p><strong>缓冲类型</strong></p>
<pre><code>1. 全缓冲:  在填满标准I/O缓冲区后才进行实际的I/O操作,对于驻留在磁盘上的文件通常是由标准I/O来实施全缓冲的.
2. 行缓冲: 当输入或者输出遇到换行符的时候, 标准I/O进行实际的I/O操作.当流涉及终端时,通常使用行缓冲
3. 不带缓冲: 标准I/O库不对字符进行缓冲存储. 标准错误流通常是不带缓冲的
</code></pre>
<hr>
<p><strong>ISO 要求的缓冲特征</strong></p>
<pre><code>1. 当且仅当标准输入和标准输出并不指向交互式设备时,他们才是全缓冲的
2. 标准错误绝对不是全缓冲的
</code></pre>
<hr>
<p><strong>冲洗(flush)</strong></p>
<pre><code>冲洗来说明标准I/O缓冲区的写操作
缓冲区可以由标准I/O例程自动冲洗, 或者调用fflush来冲洗一个流.
</code></pre>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setbuf</span><span class="params">(FILE *<span class="keyword">restrict</span> fp, <span class="keyword">char</span> *<span class="keyword">restrict</span> buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setvbuf</span><span class="params">(FILE *<span class="keyword">restrict</span> fp, <span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">int</span> mode, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fflush</span><span class="params">(FILE *fp)</span></span>; <span class="comment">// 任何时候都可以冲洗一个流</span></span><br></pre></td></tr></table></figure>

<pre><code>以上两个函数用来更改流的缓冲类型
</code></pre>
<p><strong>setbuf</strong></p>
<pre><code>可以使用setbuf函数打开或者关闭缓冲机制. 
为了带缓冲进行I/O, 参数buf必须指向一个长度为BUFSIZ的缓冲区.(BUFSIZ是定义在&lt;stdio.h&gt;的常量)
此时流就是全缓冲的, 如果与终端设备相关, 那么某些系统也会将其设置为行缓冲的.
为了关闭缓冲,将buf设置为NULL
</code></pre>
<p><strong>setvbuf</strong></p>
<pre><code>使用setvbuf, 可以精确的说明所需的缓冲类型, 这是由mode参数实现的
_IOFBF  全缓冲
_IOLBF  行缓冲
_IONBF  不带缓冲
如果指定的是不带缓冲的流, 则忽略buf和size参数. 
如果指定全缓冲或者行缓冲, 则buf和size可选择的指定一个缓冲区及其长度.
如果指定的是带缓冲的, 而buf是NULL, 则标准IO库将自动的为该流分配适当长度(BUFSIZ)的缓冲区
</code></pre>
<p><strong>记得关闭一个流</strong></p>
<h3 id="5-5-打开流"><a href="#5-5-打开流" class="headerlink" title="5.5 打开流"></a>5.5 打开流</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> type)</span></span>;</span><br><span class="line"><span class="function">FILE *<span class="title">freopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> type, FILE *<span class="keyword">restrict</span> fp)</span></span>;</span><br><span class="line"><span class="function">FILE *<span class="title">fdopen</span><span class="params">(<span class="keyword">int</span> df, <span class="keyword">const</span> <span class="keyword">char</span> *type)</span></span>;</span><br></pre></td></tr></table></figure>
<pre><code>1.  fopen 函数用来打开一个指定路径的文件
2.  freopen 在一个指定的流上打开一个指定的文件, 如果该流已经打开, 则先关闭该流.
    若该流已经定向, 则使用freopen清除该定向.一般用来打开 标准输入/标准输出/标准错误
3.  fdopen取一个已有的文件描述符,并使一个标准的IO流与该文件描述符相结合. 
    该函数常用于由创建管道和网络通信通道函数返回的描述符.
</code></pre>
<p><strong>type参数</strong> </p>
<p><img src="/image/%E6%A0%87%E5%87%86IO.png" alt="Alt text"></p>
<pre><code>使用b来区分二进制文件或者文本文件
当以读写打开一个文件时(type中+号), 具有以下限制
1. 如果中间没有fflush, fseek, fsetpos或者rewind, 则在输出的后面不能直接跟随输入
2. 如果中间没有fseek, fsetpos或者rewind, 或者一个输入操作没有到达文件尾端, 则在输入操作之后不能直接跟随输出
</code></pre>
<p><img src="/image/%E6%A0%87%E5%87%86IO2.png" alt="Alt text"></p>
<pre><code>在指定w或者a类型来创建一个新文件时, 我们无法说明文件的访问权限位,默认rw-rw-rw-
可以使用umask来限制这些权限.
</code></pre>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fclose</span><span class="params">(FILE *fp)</span></span>;</span><br></pre></td></tr></table></figure>

<pre><code>调用fclose关闭一个打开的流
文件被关闭之前, 冲洗缓冲区中的输出数据, 缓冲区中的任何输入数据被丢失.
如果标准IO已经为该流自动分配了一个缓冲区, 则释放该缓冲区
当进程正常终止时, 所有带未写缓冲区的标准IO流都被冲洗, 所有打开的标准IO流都被关闭
</code></pre>
<h3 id="5-6-读和写流"><a href="#5-6-读和写流" class="headerlink" title="5.6 读和写流"></a>5.6 读和写流</h3><pre><code>一旦打开了流, 可在三种不同类型的非格式化IO中进行选择, 对其进行读写操作
1. 每次打开一个字符的I/O. 一次读或者写一个字符, 如果流是带缓冲的, 则标准IO函数处理所有缓冲
2. 每次一行的IO. 如果想要一次读或者写一行, 则使用fgets和fputs.
3. 直接IO, fread和fwrite支持这种类型的IO. 
</code></pre>
<p><strong>输入函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getc</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetc</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getchar</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<pre><code>函数getchar等同于getc(stdin)
getc可以被实现为宏, 而fgetc不可以被实现为宏, so
1. getc的参数不能是具有副作用的表达式, 因为它可能被计算多次
2. 因为fgetc一定是个函数, 所以可以得到地址. 这就允许建fgetc的地址作为一个参数传送给另一个函数
3. 调用fgetc函数所需要的时间比getc要长, 因为调用函数所需的时间通常长于调用宏
</code></pre>
<p><strong>出错函数</strong></p>
<pre><code>无论是出错还是到达文件结尾, 这三个函数都返回同样的值. 必须调用ferror或者feof
</code></pre>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ferror</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">feof</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearerr</span><span class="params">(FILE *fp)</span></span>;</span><br></pre></td></tr></table></figure>

<pre><code>大多数实现中, 为每个流在FILE对象中维护了两个标志:
1. 出错标志
2. 文件结束标志

可以调用clearerr清除这两个标志
</code></pre>
<p><strong>压字符回流</strong></p>
<pre><code>从流中读取出的字符, 可以调用ungetc函数将字符再压送回流中. 不能回送EOF.
</code></pre>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ungetc</span><span class="params">(<span class="keyword">int</span> c,FILE *fp)</span></span>;</span><br></pre></td></tr></table></figure>


<p><strong>输出函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putc</span><span class="params">(<span class="keyword">int</span> c,FILE *fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputc</span><span class="params">(<span class="keyword">int</span> c,FILE *fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putchar</span><span class="params">(<span class="keyword">int</span> c)</span></span>;</span><br></pre></td></tr></table></figure>


<h3 id="5-7-每次一行I-O"><a href="#5-7-每次一行I-O" class="headerlink" title="5.7 每次一行I/O"></a>5.7 每次一行I/O</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">fgets</span><span class="params">(<span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">int</span> n, FILE *<span class="keyword">restrict</span> fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">gets</span><span class="params">(<span class="keyword">char</span> *buf)</span></span>;</span><br></pre></td></tr></table></figure>

<pre><code>fgets, 必须指定缓冲区长度n. 该缓冲区总是以null结尾, 
如果行数据大于n, 那么将返回一个不完整的行. 下次调用该函数, 会继续执行该行.

gets是一个不推荐使用的函数. 可能造成缓冲区溢出, 写到缓冲区之后的存储空间中.
另外, gets并不将换行符存储到缓冲区中.
</code></pre>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> str, FILE *<span class="keyword">restrict</span> fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">puts</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>;</span><br></pre></td></tr></table></figure>

<pre><code>函数fputs将一个以null字节终止的字符串写到指定的流, 尾端的终止符null不写出. 
puts与fputs的区别是, 写到标准输出流, 且每次调用之后添加一个换行符到标准输出
puts是安全的,但是也应该避免使用
</code></pre>
<h3 id="5-8-标准I-O的效率"><a href="#5-8-标准I-O的效率" class="headerlink" title="5.8  标准I/O的效率"></a>5.8  标准I/O的效率</h3><pre><code>标准IO的效率并不比直接调用read和write函数慢很多.  标准IO的优点在于不用考虑缓冲及最大IO长度的选择
</code></pre>
<h3 id="5-9-二进制I-O"><a href="#5-9-二进制I-O" class="headerlink" title="5.9 二进制I/O"></a>5.9 二进制I/O</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fread</span><span class="params">(<span class="keyword">void</span> *<span class="keyword">restrict</span> ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nobj, FILE *<span class="keyword">restrict</span> fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fwrite</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *<span class="keyword">restrict</span> ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nobj, FILE *<span class="keyword">restrict</span> fp)</span></span>;</span><br></pre></td></tr></table></figure>

<pre><code>size 是结构的长度, nobj为对象的个数.
只能读同一系统上已写的数据, 不能读其他的系统中数据.
</code></pre>
<h3 id="5-10-定位流"><a href="#5-10-定位流" class="headerlink" title="5.10 定位流"></a>5.10 定位流</h3><pre><code>三种方法可以用来定位标准I/O流. 
1. ftell和fseek函数, 这两个函数都假定文件的位置可以存放在一个长整型中.
2. ftello和fseeko函数, 文件的偏移量可以不必一定使用长整型. 他们使用off_t数据类型代替了长整型.
3. fgetops和fsetops函数. 
</code></pre>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">ftell</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseek</span><span class="params">(FILE *fp, <span class="keyword">long</span> offset, <span class="keyword">int</span> whence)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rewind</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">off_t</span> <span class="title">ftello</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseeko</span><span class="params">(FILE *fp, <span class="keyword">off_t</span> offset , <span class="keyword">int</span> whence)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetpos</span><span class="params">(FILE *<span class="keyword">restrict</span> fp, <span class="keyword">fpos_t</span> *<span class="keyword">restrict</span> pos)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsetpos</span><span class="params">(FILE *fp, <span class="keyword">const</span> <span class="keyword">fpos_t</span> *pos)</span></span>;</span><br></pre></td></tr></table></figure>

<pre><code>为了定位文本文件, whence一定是SEEK_SET, 并且offset只能是0或者ftell返回的值.
</code></pre>
<h3 id="5-11-格式化I-O"><a href="#5-11-格式化I-O" class="headerlink" title="5.11 格式化I/O"></a>5.11 格式化I/O</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fprintf</span><span class="params">(FILE *<span class="keyword">restrict</span> fp, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dprintf</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sprintf</span><span class="params">(<span class="keyword">char</span> *<span class="keyword">restrict</span> buf, cosnt <span class="keyword">char</span> *<span class="keyword">restrict</span> format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">snprintf</span><span class="params">(<span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">size_t</span> n,<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, ...)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">scanf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fscanf</span><span class="params">(FILE *<span class="keyword">restrict</span> fp, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sscanf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> format, ...)</span></span>;</span><br></pre></td></tr></table></figure>

<pre><code>snprintf : 长度超过n都被丢弃.
</code></pre>
<h3 id="5-12-实现细节"><a href="#5-12-实现细节" class="headerlink" title="5.12 实现细节"></a>5.12 实现细节</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fileno</span><span class="params">(FILE *fp)</span></span>; <span class="comment">// 通过文件指针获取文件描述符</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;apue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pr_stdio</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *, FILE *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_unbuffered</span><span class="params">(FILE *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_linebuffered</span><span class="params">(FILE *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">buffer_size</span><span class="params">(FILE *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">&quot;enter any character\n&quot;</span>, stdout);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">getchar</span>() == EOF) &#123;</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;getchar error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">&quot;one line to standard error\n&quot;</span>, stderr);</span><br><span class="line">    <span class="built_in">pr_stdio</span>(<span class="string">&quot;stdin&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">pr_stdio</span>(<span class="string">&quot;stdout&quot;</span>, stdout);</span><br><span class="line">    <span class="built_in">pr_stdio</span>(<span class="string">&quot;stderr&quot;</span>, stderr);</span><br><span class="line">    <span class="keyword">if</span> ((fp = <span class="built_in">fopen</span>(<span class="string">&quot;/etc/passwd&quot;</span>, <span class="string">&quot;r&quot;</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;fopen error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">getc</span>(fp) == EOF) &#123;</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;getc error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pr_stdio</span>(<span class="string">&quot;/etc/passwd&quot;</span>, fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pr_stdio</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, FILE *fp)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stream = %s, &quot;</span>, name);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">is_unbuffered</span>(fp)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;unbuffered&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">is_linebuffered</span>(fp)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;line buffered&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fully buffered&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;, buffer size = %d\n&quot;</span>, <span class="built_in">buffer_size</span>(fp));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(_IO_UNBUFFERED)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_unbuffered</span><span class="params">(FILE *fp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (fp-&gt;_flags &amp; _IO_UNBUFFERED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_linebuffered</span><span class="params">(FILE *fp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (fp-&gt;_flags &amp; _IO_LINE_BUF);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">buffer_size</span><span class="params">(FILE *fp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(__SNBF)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_unbuffered</span><span class="params">(FILE *fp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (fp-&gt;_flags &amp; __SNBF);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_linebuffered</span><span class="params">(FILE *fp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (fp-&gt;_flags &amp; __SLBF);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">buffer_size</span><span class="params">(FILE *fp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (fp-&gt;_bf._size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(_IONBF)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _LP64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _flag __pad[4]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _ptr __pad[1]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _base __pad[2]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_unbuffered</span><span class="params">(FILE *fp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (fp-&gt;_flags &amp; _IONBF);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_linebuffered</span><span class="params">(FILE *fp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (fp-&gt;_flags &amp; _IOLBF);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">buffer_size</span><span class="params">(FILE *fp)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _LP64</span></span><br><span class="line">    <span class="keyword">return</span> (fp-&gt;_base - fp-&gt;_ptr);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">return</span> BUFSIZ;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">error</span> unknown stdio implementation!</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="5-13-临时文件"><a href="#5-13-临时文件" class="headerlink" title="5.13 临时文件"></a>5.13 临时文件</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">tmpnam</span><span class="params">(<span class="keyword">char</span> *ptr)</span></span>;</span><br><span class="line"><span class="function">FILE *<span class="title">tmpfile</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<pre><code>tmpnam函数产生一个与现有文件名不同的一个有效路径名字符串.(只产生一个字符串)
如果传入的参数为NULL, 会将文件名存储在静态区, 如果传入的参数为至少是L_tmpnam个字符的数组, 返回该数组指针.
tmpfile 创建一个临时二进制文件. 但是立即被删除. 看不到的...
</code></pre>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">mkdtemp</span><span class="params">(<span class="keyword">char</span> *<span class="keyword">template</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkstemp</span><span class="params">(<span class="keyword">char</span> *<span class="keyword">template</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<pre><code>mkdtemp 函数创建了一个目录, 该目录有一个唯一的名字. 权限为`rwx------ `
mkstemp 函数创建了一个文件, 该文件有一个唯一的名字. 权限为`rw-------`
名字是通过template字符串进行选择的. 这个字符串是后六位设置为XXXXXX的路径名.
</code></pre>
<h3 id="5-14-内存流"><a href="#5-14-内存流" class="headerlink" title="5.14 内存流"></a>5.14 内存流</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function">FILE *<span class="title">fmemopen</span><span class="params">(<span class="keyword">void</span> *<span class="keyword">restrict</span> buf, <span class="keyword">size_t</span> size, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> type)</span></span>;</span><br></pre></td></tr></table></figure>

<pre><code>内存流: 虽然仍使用FILE指针进行访问, 但其实并没有底层文件, 所有的IO都是通过在缓冲区与主存之间来回传送字节来完成的.
fmemopen函数允许调用者提供缓冲区用于内存流. 如果buf参数为空, fmemopen函数分配size字节数的缓冲区, 这种情况下, 流关闭, 缓冲区关闭.
type参数控制如何使用流...取值对应基于文件的标准I/O的type参数取值, 但其中有微小的差别.
1.  无论何时以追加写方式打开内存流时, 当前文件的位置设置为缓冲区的第一个null字节.
    如果缓冲区中不存在null字节, 则当前位置就设置为缓冲区结尾的后一个字节.
    当流不是以追加写方式打开时, 当前位置设置为缓冲区的开始位置.
2.  如果buf参数是一个null指针, 打开流进行读或者写都没有任何意义, 因为在这种情况下, 缓冲区是通过fmemopen进行分配的, 找不到缓冲区地址.
3.  任何时候需要增加流缓冲区的数据量以及调用fclose,fflush,fseek, fseeko以及fsetpos时都会在当前位置写入一个null字节
</code></pre>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个代码在Mac和Linux上执行的结果不一样...</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;apue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BSZ 48</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">char</span> buf[BSZ];</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">&#x27;a&#x27;</span>, BSZ - <span class="number">2</span>);</span><br><span class="line">    buf[BSZ - <span class="number">2</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    buf[BSZ - <span class="number">1</span>] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> ((fp = <span class="built_in">fmemopen</span>(buf, BSZ, <span class="string">&quot;w+&quot;</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;fmemopen failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;initial buffer contents: %s\n&quot;</span>, buf);</span><br><span class="line">    <span class="built_in">fprintf</span>(fp, <span class="string">&quot;hello, world&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;before flush: %s\n&quot;</span>, buf);</span><br><span class="line">    <span class="built_in">fflush</span>(fp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;after flush: %s\n&quot;</span>, buf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;len of string in buf = %ld\n&quot;</span>, (<span class="keyword">long</span>)<span class="built_in">strlen</span>(buf));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">&#x27;b&#x27;</span>, BSZ - <span class="number">2</span>);</span><br><span class="line">    buf[BSZ - <span class="number">2</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    buf[BSZ - <span class="number">1</span>] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">    <span class="built_in">fprintf</span>(fp, <span class="string">&quot;hello, world&quot;</span>);</span><br><span class="line">    <span class="built_in">fseek</span>(fp, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;after fseek: %s\n&quot;</span>, buf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;len of string in buf = %ld\n&quot;</span>, (<span class="keyword">long</span>)<span class="built_in">strlen</span>(buf));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">&#x27;c&#x27;</span>, BSZ - <span class="number">2</span>);</span><br><span class="line">    buf[BSZ - <span class="number">2</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    buf[BSZ - <span class="number">1</span>] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">    <span class="built_in">fprintf</span>(fp, <span class="string">&quot;hello, world&quot;</span>);</span><br><span class="line">    <span class="built_in">fclose</span>(fp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;after fseek: %s\n&quot;</span>, buf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;len of string in buf = %ld\n&quot;</span>, (<span class="keyword">long</span>)<span class="built_in">strlen</span>(buf));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function">FILE *<span class="title">open_memstream</span><span class="params">(<span class="keyword">char</span> **bufp, <span class="keyword">size_t</span> *sizep)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wchar.h&gt;</span></span></span><br><span class="line"><span class="function">FILE *<span class="title">open_wmenstream</span><span class="params">(<span class="keyword">wchar_t</span> **bufp, <span class="keyword">size_t</span> *sizep)</span></span>;</span><br></pre></td></tr></table></figure>

<pre><code>与fmemopen的区别是, 
1. 创建的流只能写打开
2. 不能指定自己的缓冲区. 通过bufp和sizep参数访问缓冲区地址和大小.
3. 关闭流之后需要自行释放缓冲区
4. 对流添加字节会增加缓冲区大小.
</code></pre>
<p><strong>遵守的规则</strong></p>
<pre><code>1. 缓冲区地址和长度只有在调用了fclose或者fflush后才有效
2. 这些值只有在下一次流写入或调用fclose前才有效.(这地方是不是有问题啊...)
</code></pre>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/12/APUE-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/default.png">
      <meta itemprop="name" content="zinego">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zinego's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/02/12/APUE-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86/" class="post-title-link" itemprop="url">APUE 阅读笔记 第四章 文件和目录 第二部分</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-02-12 16:21:39" itemprop="dateCreated datePublished" datetime="2019-02-12T16:21:39+08:00">2019-02-12</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-31 13:59:30" itemprop="dateModified" datetime="2021-10-31T13:59:30+08:00">2021-10-31</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/APUE%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">APUE阅读笔记</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="第四章-文件和目录-第二部分"><a href="#第四章-文件和目录-第二部分" class="headerlink" title="第四章 文件和目录 第二部分"></a>第四章 文件和目录 第二部分</h2><h3 id="4-12-文件长度"><a href="#4-12-文件长度" class="headerlink" title="4.12 文件长度"></a>4.12 文件长度</h3><pre><code>stat结构成员st_size表示以字节为单位的文件的长度.
此字段只对普通文件/目录文件/符号链接有意义
对于符号链接, 文件长度实际上是文件名中的实际字符数
</code></pre>
<p><strong>文件空洞</strong></p>
<pre><code>关于文件空洞, 实际上是偏移量超过文件尾端, 并写入了数据造成的.
(系统中的du报告的是512字节块的块数或者是1024字节块的块数)
使用实用程序复制空洞文件, 文件空洞会被填满, 实际字节填为0
</code></pre>
<h3 id="4-13-文件截断"><a href="#4-13-文件截断" class="headerlink" title="4.13 文件截断"></a>4.13 文件截断</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">truncate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">off_t</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ftruncate</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure>
<pre><code>有时我们需要在文件尾端截去一些数据以缩短文件. 
将一个文件的长度阶段为0是一个特例, 在打开文件时使用O_TRUNC标志可以做到这一点.
截断文件可以使用上面的两个文件
如果之前的文件长度超过length, 那么超过length之后的文件内容不能被访问
如果之前的文件长度少于length, 那么文件的长度将增加, 后面的是文件空洞
</code></pre>
<h3 id="4-14-文件系统"><a href="#4-14-文件系统" class="headerlink" title="4.14 文件系统"></a>4.14 文件系统</h3><pre><code>可以把一个磁盘分成一个或者多个分区, 每个分区可以包含一个文件系统, 如下图
节点是固定长度的记录项, 包含文件的绝大部分信息. 
</code></pre>
<p><img src="/image/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F1.png" alt="Alt text"></p>
<p><img src="/image/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F2.png" alt="Alt text"></p>
<p><strong>引用计数</strong></p>
<pre><code>如上图所示, 多个目录项指向一个i节点, 每个i节点中都有一个连接计数, 
只有当连接计数减少至0时, 才可以删除该文件(释放文件占用的数据块)
解除文件的连接并不意味着释放该文件占用的磁盘块
stat结构中, 连接计数被保存在`st_nlink`中
</code></pre>
<p><strong>符号链接</strong></p>
<pre><code>符号链接文件的实际内容(在数据块中)包含了该符号连接所指向的文件的名字
</code></pre>
<p><strong>i节点</strong></p>
<pre><code>i节点存储文件的所有信息, 包含文件类型, 文件访问权限位, 文件长度和指向文件数据库的指针等.
stat结构的大部分信息都取自i节点. 只有两项重要数据存放在目录项中: 文件名和i节点编号
i节点编号的数据类型是ino_t
</code></pre>
<p><strong>文件系统隔离</strong></p>
<pre><code>因为目录项中的i节点编号指向同一文件系统中相应的i节点,
一个目录项不能指向了另一个文件系统的i节点. 
这就是为什么ln命令不能跨越文件系统的缘故
</code></pre>
<p><strong>重命名文件</strong></p>
<pre><code>当不更换文件系统的情况下问一个文件重命名时, 文件的实际内容并未移动. 
只需要构造一个指向现有i节点的新目录项, 并删除老的目录项, 连接计数不会改变.
</code></pre>
<p><img src="/image/%E6%96%87%E4%BB%B6%E9%87%8D%E5%91%BD%E5%90%8D.png" alt="Alt text"></p>
<p><strong>目录文件的连接计数</strong></p>
<pre><code>编号2549的节点, 其类型字段标识它是一个目录, 连接计数为2. 
任何一个叶子目录的连接计数总是2
数值2来自命名该目录的目录项以及该目录中的.项
</code></pre>
<hr>
<pre><code>编号为1267的i节点, 其类型字段标识它是一个目录, 连接技术大于或者等于3.
大于等于3的原因是: 至少有三个目录项指向它: 命名它的目录, 该目录中的.项, 还有其子目录中的..项
</code></pre>
<h3 id="4-15-函数link-linkat-unlink-unlinkat和remove"><a href="#4-15-函数link-linkat-unlink-unlinkat和remove" class="headerlink" title="4.15 函数link, linkat, unlink, unlinkat和remove"></a>4.15 函数link, linkat, unlink, unlinkat和remove</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">link</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *existingpath, <span class="keyword">const</span> <span class="keyword">char</span> *newpath)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">linkat</span><span class="params">(<span class="keyword">int</span> efd, <span class="keyword">const</span> <span class="keyword">char</span> *existingpath, <span class="keyword">int</span> nfd, <span class="keyword">const</span> <span class="keyword">char</span> *newpath, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unlinkat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flag)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>创建连接</strong></p>
<pre><code>前两个函数创建一个新的目录项newpath, 它引用现有文件existingpath. 
如果newpath已经存在, 则返回出错.
只创建路径中的一个分量, 路径中的其他部分应当已经存在
flag用来决定指向现有符号连接还是指向符号连接指向的文件
创建目录项和增加引用计数应当是一个原子操作
</code></pre>
<p><strong>删除连接</strong></p>
<pre><code>后两个函数删除目录项, 并将由pathname所引用的文件的链接计数减一.
为了解除对文件的连接, 必须对包含该目录的目录具有写和执行权限
只有链接计数达到0 , 文件才可以删除. 进程打开了文件, 其内容也不能删除.
关闭一个文件时, 内核首先检查打开该文件的进程个数, 如果这个计数达到0 , 再去检查其链接计数
当flag参数设置了AT_REMOVEDIR标志时, 函数可以类似与rmdir那样删除目录.
</code></pre>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;apue.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">open</span>(<span class="string">&quot;foo&quot;</span>, O_RDWR) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">unlink</span>(<span class="string">&quot;foo&quot;</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;unlink error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;file unlinked\n&quot;</span>);</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">15</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;done&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>unlink这种特性用来保证即使是在程序崩溃时, 所创建的临时文件也不会被遗留下来.
进程使用open或create创建一个文件, 立即unlink即可
如果filepath是符号链接, 那么只能删除符号链接,而不能删除文件.
没有一个函数能删除符号链接引用的文件
</code></pre>
<h3 id="4-16-函数rename和renameat"><a href="#4-16-函数rename和renameat" class="headerlink" title="4.16 函数rename和renameat"></a>4.16 函数rename和renameat</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rename</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *oldname, <span class="keyword">const</span> <span class="keyword">char</span> *newname)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">renameat</span><span class="params">(<span class="keyword">int</span> oldfd, <span class="keyword">const</span> <span class="keyword">char</span> *oldname, <span class="keyword">int</span> newfd, <span class="keyword">const</span> <span class="keyword">char</span> *newname)</span></span>;</span><br></pre></td></tr></table></figure>






<p><strong>oldname是文件</strong></p>
<pre><code>如果oldname是一个文件, 那么newname不能是一个已经存在的目录,
如果newname已经存在,但不是目录, 则先将该目录项删除, 并将oldname命名为newname.
</code></pre>
<p><strong>oldname是目录</strong></p>
<pre><code>如果newname已经存在, 那么它必须是一个目录, 而且必须是一个空目录
如果newname已经存在, 且是空目录, 先将其删除, 然后将old命名为newname
且newname不能包含oldname作为其路径前缀, 例如将/usr/foo命名为/usr/foo/test
</code></pre>
<p><strong>符号链接</strong></p>
<pre><code>如果oldname或newname引用符号链接, 那么处理的是符号链接本身, 不影响引用的文件
</code></pre>
<p><strong>./..</strong></p>
<pre><code>不能对. / .. 重命名
</code></pre>
<p><strong>同一文件</strong></p>
<pre><code>如果oldname和newname引用同一文件, 那么函数不做任何更改就返回
</code></pre>
<h3 id="4-17-符号链接"><a href="#4-17-符号链接" class="headerlink" title="4.17 符号链接"></a>4.17 符号链接</h3><pre><code>符号链接是一个文件的间接指针, 硬链接直接指向文件的i节点.
引入符号链接是为了避免硬链接的一些限制
1. 硬链接通常要求在同一个文件系统中
2. 只有超级用户才能创建指向目录的硬链接
一些函数不支持符号链接, 慎用
</code></pre>
<h3 id="4-18-创建和读取符号链接"><a href="#4-18-创建和读取符号链接" class="headerlink" title="4.18 创建和读取符号链接"></a>4.18 创建和读取符号链接</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">symlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *actualpath, <span class="keyword">const</span> <span class="keyword">char</span> *sympath)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">symlinkat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *actualpath, <span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *sympath)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">readlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, <span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">size_t</span> bufsize)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">readlinkat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, <span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">size_t</span> bufsize)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>读取</strong></p>
<pre><code>创建一个纸箱actualpath的新目录项sympath
在创建时, 并不要求actualpath存在.且两者并不需要位于同一文件系统中
</code></pre>
<p><strong>读取</strong></p>
<pre><code>两个函数组合了open, read, close的所有操作.
如果函数成功执行, 返回读入buf的字节数.
在buf中返回的符号链接内容并不以null字节终止
</code></pre>
<h3 id="4-19-文件的时间"><a href="#4-19-文件的时间" class="headerlink" title="4.19 文件的时间"></a>4.19 文件的时间</h3><pre><code>对每个文件维护三个字段, 他们的意义如下
</code></pre>
<table>
<thead>
<tr>
<th align="left">字段</th>
<th align="right">说明</th>
<th align="right">例子</th>
<th align="center">ls选项</th>
</tr>
</thead>
<tbody><tr>
<td align="left">st_atim</td>
<td align="right">文件数据的最后访问时间</td>
<td align="right">read</td>
<td align="center">-u</td>
</tr>
<tr>
<td align="left">st_mtim</td>
<td align="right">文件数据的最后修改时间</td>
<td align="right">write</td>
<td align="center">默认</td>
</tr>
<tr>
<td align="left">st_ctim</td>
<td align="right">i节点状态的最后更改时间</td>
<td align="right">chown, chmode</td>
<td align="center">-c</td>
</tr>
</tbody></table>
<pre><code>修改时间是文件内容最后一次被修改的时间
状态更改时间是该文件的i节点最后一次被修改的时间.
</code></pre>
<h3 id="4-20-函数futimens-utimensat-utimes"><a href="#4-20-函数futimens-utimensat-utimes" class="headerlink" title="4.20 函数futimens, utimensat, utimes"></a>4.20 函数futimens, utimensat, utimes</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">futimens</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct timespec times[<span class="number">2</span>])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">utimensat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> struct timespec times[<span class="number">2</span>], <span class="keyword">int</span> flag)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">utime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">const</span> struct timeval times[<span class="number">2</span>])</span></span></span><br></pre></td></tr></table></figure>

<p><strong>时间</strong></p>
<pre><code>这两个函数的times数组的第一个元素包含访问时间, 第二元素包含修改时间. 是时间戳
1. 如果times参数是一个空指针,则访问时间和修改时间两者都设置为当前时间
2. 如果times参数指向两个timespec结构的数组, 任意数组元素的tv_nsec字段的值为UTIME_NOW,
相应的时间戳设置为当前时间, 忽略相应的tv_sec字段
3. 如果times参数指向两个timespec结构的数组, 任意数组元素的tv_nsec字段的值为UTIME_OMIT,
相应的时间戳不变, 忽略tv_sec字段
4. 如果times参数指向两个timespec结构的数组, tv_nsec的值既不是UTIME_NOW也不是UTIME_OMIT, 
相应的时间设置为tv_sec和tv_nsec的值
</code></pre>
<p><strong>权限</strong></p>
<pre><code>1. 如果times参数是一个空指针, 或者任意数组元素的tv_nsec字段的值为UTIME_NOW,
则进程的有效用户ID必须等于该文件的所有者ID, 进程必须对文件具有写权限,
或者进程是一个超级用户进程
2. 如果times参数是一个非空指针,
并且任意tv_nsec字段的值都为既不是UTIME_OMIT又不是UTIME_NOW,
则进程有效用户ID必须等于该文件的所有者ID, 或者进程必须是一个超级用户进程,
对文件只有写权限是不够
3. 如果times参数是一个非空指针, 并且任意tv_nsec字段的值都为UTIME_OMIT,
就不执行任何权限检查
</code></pre>
<hr>
<pre><code>futimens 函数需要打开文件开更改它的时间,utimensat函数提供了一种使用文件名更改时间的方法.
如果fd是AT_FDCWD, 那么通过当前进程的目录来计算filepath. 
如果pathname是绝对路径, 那么fd将被忽略
utimensat的flag参数来决定是否跟随符号链接
</code></pre>
<p><strong>utimes</strong></p>
<pre><code>utimes函数对路径名进行操作. times参数是指向包含两个时间戳元素(访问时间和修改时间)的数组的指针.
我们不能对状态更改时间st_ctim指定一个值, 因为调用utimes函数时, 该状态会自动更新
</code></pre>
<h3 id="4-21-函数mkdir-mkdirat-rmdir"><a href="#4-21-函数mkdir-mkdirat-rmdir" class="headerlink" title="4.21 函数mkdir, mkdirat, rmdir"></a>4.21 函数mkdir, mkdirat, rmdir</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkdirat</span> <span class="params">(<span class="keyword">int</span> fd,<span class="keyword">const</span> <span class="keyword">char</span> *pathname,<span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure>

<pre><code>这两个函数创建一个空目录, 其中.和..目录项是自动创建的.
所指定的文件访问权限mode由进程的文件模式创建屏蔽字修改
</code></pre>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rmdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</span><br></pre></td></tr></table></figure>
<pre><code>用rmdir只能删除空目录.
</code></pre>
<h3 id="4-22-读目录"><a href="#4-22-读目录" class="headerlink" title="4.22 读目录"></a>4.22 读目录</h3><pre><code>对目录具有访问权限的任意用户都可以读目录. 但是只有内核才能写目录. 
一个目录的写权限位和执行权限位决定了在该目录中能否创建新文件
</code></pre>
<h3 id="4-23-函数chdir-fchdir和getcwd"><a href="#4-23-函数chdir-fchdir和getcwd" class="headerlink" title="4.23 函数chdir, fchdir和getcwd"></a>4.23 函数chdir, fchdir和getcwd</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchdir</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure>

<pre><code>每个进程都有当前工作目录, 此目录是搜索所有相对路径名的起点. 
进程调用上面的两个函数来更改当前工作目录.
只影响调用chdir的程序
</code></pre>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getcwd</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">size_t</span> size)</span></span>; <span class="comment">// 参数为缓冲区的地址和缓冲区大小(该函数获取当前工作目录的绝对路径)</span></span><br></pre></td></tr></table></figure>




<h3 id="4-24-设备特殊文件"><a href="#4-24-设备特殊文件" class="headerlink" title="4.24 设备特殊文件"></a>4.24 设备特殊文件</h3><h3 id="4-25-文件访问权限位小结"><a href="#4-25-文件访问权限位小结" class="headerlink" title="4.25 文件访问权限位小结"></a>4.25 文件访问权限位小结</h3><p><img src="/image/%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E4%BD%8D.png" alt="Alt text"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/25/RSA-%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%88%9D%E6%8E%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/default.png">
      <meta itemprop="name" content="zinego">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zinego's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/01/25/RSA-%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%88%9D%E6%8E%A2/" class="post-title-link" itemprop="url">RSA 加密算法初探</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-01-25 20:39:12" itemprop="dateCreated datePublished" datetime="2019-01-25T20:39:12+08:00">2019-01-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-31 12:16:22" itemprop="dateModified" datetime="2021-10-31T12:16:22+08:00">2021-10-31</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%8A%A0%E5%AF%86-%E7%AD%BE%E5%90%8D-%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">加密/签名/安全</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>811</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="RSA-加密算法初探"><a href="#RSA-加密算法初探" class="headerlink" title="RSA 加密算法初探"></a>RSA 加密算法初探</h2><h3 id="1-公钥和私钥的产生"><a href="#1-公钥和私钥的产生" class="headerlink" title="1. 公钥和私钥的产生"></a>1. 公钥和私钥的产生</h3><pre><code>1. 随机选择两个大的素数p!=q, 计算N=p*q
2. 根据欧拉函数, 求得 r=φ(N)=φ(p)φ(q)=(p-1)*(q-1)
3. 选择一个小于r且与r互质的整数e, 并求得e关于r的模逆元, 命名为d. 即d*e%r=1
4. 将p和q的记录销毁
5. (N,e)是公钥, (N,d)是私钥
</code></pre>
<p><strong>一些基础知识</strong></p>
<pre><code>1. n的欧拉函数指的是1~n-1之间与n互质的数的个数
2. 一个素数n的欧拉函数等于n-1
3. (a^b)%p=(a^b%φ(p))%p
</code></pre>
<h3 id="2-加密消息"><a href="#2-加密消息" class="headerlink" title="2. 加密消息"></a>2. 加密消息</h3><pre><code>1. 消息发送方知道公钥(N,e)
2. 消息发送方将消息转化为小于N的非负整数n(比如可以将字转化为该字的Unicode码, 可以分几段, 然后将每一段转化为n)
3. 用公式 c=n^e%N
4. 将消息发送给消息接受者
</code></pre>
<h3 id="3-解密消息"><a href="#3-解密消息" class="headerlink" title="3. 解密消息"></a>3. 解密消息</h3><pre><code>1. 消息接受者接收到消息, 拿到n
2. 利用公式n=c^d%N来将c转化为n. (n = (c^d)%N = ((n^e)^d)%N = (n^(de%φ(N)))%N = (n^(de%r))%N = n%N = n)
</code></pre>
<h3 id="4-签名消息"><a href="#4-签名消息" class="headerlink" title="4. 签名消息"></a>4. 签名消息</h3><p><strong>发送者</strong></p>
<pre><code>1. 计算消息的散列值(MD5,sha1)
2. 加密散列值, 并将加密后的散列值(签名)加在消息后面.
3. 发送消息
</code></pre>
<p><strong>接受者</strong></p>
<pre><code>1. 接受消息
2. 使用公钥解密这个散列值
3. 计算消息的散列值, 比较两个散列值是否相同. 
</code></pre>
<p><strong>意义</strong></p>
<pre><code>签名消息可以保证消息在传递过程中没有被伪造, 也没有人篡改消息
加密/解密消息可以保证消息在传递过程中不会被他人获取
其实公钥和私钥都能用来加密和解密(理论上是如此, 毕竟逆元是相互的, 但不知安全上是否有影响), 但一定有一个不公开...
</code></pre>
<h3 id="5-安全"><a href="#5-安全" class="headerlink" title="5. 安全"></a>5. 安全</h3><pre><code>公钥(N,e)是公开的, 加密消息c可能被获取. 但是想解密还需要私钥, 虽然可以通过N分解出pq来算出私钥, 
但至今为止还没有人找到一个多项式时间的算法来分解一个大的整数的因子，同时也还没有人能够证明这种算法不存在
目前认为N足够大, 黑客就没办法了.
当前推荐N的长度至少为2048位
</code></pre>
<ul>
<li>以上信息摘自<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/RSA%E5%8A%A0%E5%AF%86%E6%BC%94%E7%AE%97%E6%B3%95">维基百科</a></li>
</ul>
<hr>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/23/%E9%98%BF%E9%87%8C%E4%BA%91%E6%B6%88%E6%81%AF%E6%9C%8D%E5%8A%A1MNS-EndPoint%E7%AD%BE%E5%90%8D%E8%AE%A4%E8%AF%81-Golang/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/default.png">
      <meta itemprop="name" content="zinego">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zinego's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/01/23/%E9%98%BF%E9%87%8C%E4%BA%91%E6%B6%88%E6%81%AF%E6%9C%8D%E5%8A%A1MNS-EndPoint%E7%AD%BE%E5%90%8D%E8%AE%A4%E8%AF%81-Golang/" class="post-title-link" itemprop="url">阿里云消息服务MNS EndPoint签名认证 Golang</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-01-23 15:06:11" itemprop="dateCreated datePublished" datetime="2019-01-23T15:06:11+08:00">2019-01-23</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-31 12:16:22" itemprop="dateModified" datetime="2021-10-31T12:16:22+08:00">2021-10-31</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%8A%A0%E5%AF%86-%E7%AD%BE%E5%90%8D-%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">加密/签名/安全</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="阿里云消息服务MNS-EndPoint签名认证-Golang"><a href="#阿里云消息服务MNS-EndPoint签名认证-Golang" class="headerlink" title="阿里云消息服务MNS EndPoint签名认证 Golang"></a>阿里云消息服务MNS EndPoint签名认证 Golang</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>公司业务, 需要进行媒体转码服务, 转码之后需要接受阿里云的回调, 我们采用<a target="_blank" rel="noopener" href="https://help.aliyun.com/document_detail/44602.html?spm=a2c4g.11186623.6.628.7b4840d6n7oJN6">主题通知方式接受消息</a><br>此时需要为阿里云提供一个暴露在公网上面的接口, 所以要避免非法的攻击调用. 此时使用阿里的<a target="_blank" rel="noopener" href="https://help.aliyun.com/document_detail/27488.html?spm=a2c4g.11186623.2.11.663d440bGv2Qab">EndPoint签名认证</a><br>文档中已经有Java代码是如何进行验证的, 我在这里只是做了个转换. </p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul>
<li>从x-mns-signing-cert-url中取出base64加密后的url, 解密, 获得url</li>
<li>http请求url获取pem证书, 解析证书, 获取<strong>公钥</strong></li>
<li>从header中获取<strong>待签名的字符串</strong></li>
<li>从header中获取加密后的Authorization, 解密, 获得<strong>待验证的签名</strong></li>
<li>sha1对<strong>待签名的字符串</strong>sha1加密, 进行sha1rsa签名, 与<strong>待验证的签名</strong>对比</li>
</ul>
<h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SignDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Boolean <span class="title">authenticate</span><span class="params">(String method, String uri, Map&lt;String, String&gt; headers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取证书的URL</span></span><br><span class="line">            <span class="keyword">if</span> (!headers.containsKey(<span class="string">&quot;x-mns-signing-cert-url&quot;</span>)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;x-mns-signing-cert-url Header not found&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            String cert = headers.get(<span class="string">&quot;x-mns-signing-cert-url&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (cert.isEmpty()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;x-mns-signing-cert-url empty&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cert = <span class="keyword">new</span> String(Base64.decodeBase64(cert));</span><br><span class="line">            System.out.println(<span class="string">&quot;x-mns-signing-cert-url:\t&quot;</span> + cert);</span><br><span class="line">            <span class="comment">//根据URL获取证书，并从证书中获取公钥</span></span><br><span class="line">            URL url = <span class="keyword">new</span> URL(cert);</span><br><span class="line">            HttpURLConnection conn = (HttpURLConnection) url.openConnection();</span><br><span class="line">            DataInputStream in = <span class="keyword">new</span> DataInputStream(conn.getInputStream());</span><br><span class="line">            CertificateFactory cf = CertificateFactory.getInstance(<span class="string">&quot;X.509&quot;</span>);</span><br><span class="line">            Certificate c = cf.generateCertificate(in);</span><br><span class="line">            PublicKey pk = c.getPublicKey();</span><br><span class="line">            <span class="comment">//获取待签名字符串</span></span><br><span class="line">            String str2sign = getSignStr(method, uri, headers);</span><br><span class="line">            System.out.println(<span class="string">&quot;String2Sign:\t&quot;</span> + str2sign);</span><br><span class="line">            <span class="comment">//对Authorization字段做Base64解码</span></span><br><span class="line">            String signature = headers.get(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">            <span class="keyword">byte</span>[] decodedSign = Base64.decodeBase64(signature);</span><br><span class="line">            <span class="comment">//认证</span></span><br><span class="line">            java.security.Signature signetcheck = java.security.Signature.getInstance(<span class="string">&quot;SHA1withRSA&quot;</span>);</span><br><span class="line">            signetcheck.initVerify(pk);</span><br><span class="line">            signetcheck.update(str2sign.getBytes());</span><br><span class="line">            Boolean res = signetcheck.verify(decodedSign);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getSignStr</span><span class="params">(String method, String uri, Map&lt;String, String&gt; headers)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(method);</span><br><span class="line">        sb.append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        sb.append(safeGetHeader(headers, <span class="string">&quot;Content-md5&quot;</span>));</span><br><span class="line">        sb.append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        sb.append(safeGetHeader(headers, <span class="string">&quot;Content-Type&quot;</span>));</span><br><span class="line">        sb.append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        sb.append(safeGetHeader(headers, <span class="string">&quot;Date&quot;</span>));</span><br><span class="line">        sb.append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        List&lt;String&gt; tmp = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : headers.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.getKey().startsWith(<span class="string">&quot;x-mns-&quot;</span>)) &#123;</span><br><span class="line">                tmp.add(entry.getKey() + <span class="string">&quot;:&quot;</span> + entry.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(tmp);</span><br><span class="line">        <span class="keyword">for</span> (String kv : tmp) &#123;</span><br><span class="line">            sb.append(kv);</span><br><span class="line">            sb.append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(uri);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">safeGetHeader</span><span class="params">(Map&lt;String, String&gt; headers, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (headers.containsKey(name)) &#123;</span><br><span class="line">            <span class="keyword">return</span> headers.get(name);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SignDemo sd = <span class="keyword">new</span> SignDemo();</span><br><span class="line">        Map&lt;String, String&gt; headers = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        headers.put(<span class="string">&quot;Authorization&quot;</span>, <span class="string">&quot;Mko2Azg9fhCw8qR6G7AeAFMyzjO9qn7LDA5/t9E+6X5XURXTqBUuhpK+K55UNhrnlE2UdDkRrwDxsaDP5ajQdg==&quot;</span>);</span><br><span class="line">        headers.put(<span class="string">&quot;Content-md5&quot;</span>, <span class="string">&quot;M2ViOTE2ZDEyOTlkODBjMjVkNzM4YjNhNWI3ZWQ1M2E=&quot;</span>);</span><br><span class="line">        headers.put(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/xml;charset=utf-8&quot;</span>);</span><br><span class="line">        headers.put(<span class="string">&quot;Date&quot;</span>, <span class="string">&quot;Tue, 23 Feb 2016 09:41:06 GMT&quot;</span>);</span><br><span class="line">        headers.put(<span class="string">&quot;x-mns-request-id&quot;</span>, <span class="string">&quot;56CC2932F0E3D5BD530685CB&quot;</span>);</span><br><span class="line">        headers.put(<span class="string">&quot;x-mns-signing-cert-url&quot;</span>, <span class="string">&quot;aHR0cDovL21uc3Rlc3Qub3NzLWNuLWhhbmd6aG91LmFsaXl1bmNzLmNvbS94NTA5X3B1YmxpY19jZXJ0aWZpY2F0ZS5wZW0=&quot;</span>);</span><br><span class="line">        headers.put(<span class="string">&quot;x-mns-version&quot;</span>, <span class="string">&quot;2015-06-06&quot;</span>);</span><br><span class="line">        Boolean res = sd.authenticate(<span class="string">&quot;POST&quot;</span>, <span class="string">&quot;/notifications&quot;</span>, headers);</span><br><span class="line">        System.out.println(<span class="string">&quot;Authenticate result:&quot;</span> + res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Golang代码"><a href="#Golang代码" class="headerlink" title="Golang代码"></a>Golang代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;crypto&quot;</span></span><br><span class="line">	<span class="string">&quot;crypto/rsa&quot;</span></span><br><span class="line">	<span class="string">&quot;crypto/sha1&quot;</span></span><br><span class="line">	<span class="string">&quot;crypto/x509&quot;</span></span><br><span class="line">	<span class="string">&quot;encoding/base64&quot;</span></span><br><span class="line">	<span class="string">&quot;encoding/pem&quot;</span></span><br><span class="line">	<span class="string">&quot;errors&quot;</span></span><br><span class="line">	<span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	<span class="string">&quot;sort&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AliNotification</span><span class="params">(method <span class="keyword">string</span>, uri <span class="keyword">string</span>, header http.Header)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// 提取url , 获取证书, 解析出公钥</span></span><br><span class="line">	urlBase64 := header.Get(<span class="string">&quot;x-mns-signing-cert-url&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> urlBase64 == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		log.Println(<span class="string">&quot;x-mns-signing-cert-url Header not found&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;x-mns-signing-cert-url Header not found&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	body, err := base64.StdEncoding.DecodeString(urlBase64)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(<span class="string">&quot;解码失败&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;解码失败&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	certUrl := <span class="keyword">string</span>(body)</span><br><span class="line">	log.Println(<span class="string">&quot;x-mns-signing-cert-url:\t&quot;</span>, certUrl)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 请求url, 获得证书</span></span><br><span class="line">	resp, err := http.Get(certUrl)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(<span class="string">&quot;请求x-mns-signing-cert-url失败&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;请求x-mns-signing-cert-url失败&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">	body, err = ioutil.ReadAll(resp.Body)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(<span class="string">&quot;解析x-mns-signing-cert-url失败&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;解析x-mns-signing-cert-url失败&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 解析证书</span></span><br><span class="line">	p, rest := pem.Decode(body)</span><br><span class="line">	<span class="keyword">if</span> p == <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(<span class="string">&quot;获取公钥失败&quot;</span>, <span class="keyword">string</span>(rest))</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;获取公钥失败&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	cert, err := x509.ParseCertificate(p.Bytes)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(<span class="string">&quot;证书文件格式不合法, 解析失败&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;证书文件格式不合法, 解析失败&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	publicKey, ok := cert.PublicKey.(*rsa.PublicKey)</span><br><span class="line">	<span class="keyword">if</span> ok == <span class="literal">false</span> &#123;</span><br><span class="line">		log.Println(<span class="string">&quot;公钥格式不正确&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;公钥格式不正确&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	log.Println(cert.PublicKey)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取待签名字符串</span></span><br><span class="line">	str := <span class="string">&quot;&quot;</span></span><br><span class="line">	str = str + method + <span class="string">&quot;\n&quot;</span></span><br><span class="line">	str = str + header.Get(<span class="string">&quot;Content-md5&quot;</span>) + <span class="string">&quot;\n&quot;</span></span><br><span class="line">	str = str + header.Get(<span class="string">&quot;Content-Type&quot;</span>) + <span class="string">&quot;\n&quot;</span></span><br><span class="line">	str = str + header.Get(<span class="string">&quot;Date&quot;</span>) + <span class="string">&quot;\n&quot;</span></span><br><span class="line">	<span class="keyword">var</span> arr sort.StringSlice</span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> header &#123;</span><br><span class="line">		<span class="comment">// golang 的header.Set方法会将header里面key的首字母大写, 所以还要转换一下, 好傻</span></span><br><span class="line">		k = strings.ToLower(k)</span><br><span class="line">		<span class="keyword">if</span> strings.HasPrefix(k, <span class="string">&quot;x-mns-&quot;</span>) &amp;&amp; <span class="built_in">len</span>(v) != <span class="number">0</span> &#123;</span><br><span class="line">			arr = <span class="built_in">append</span>(arr, k+<span class="string">&quot;:&quot;</span>+v[<span class="number">0</span>])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	sort.Sort(arr)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> arr &#123;</span><br><span class="line">		str = str + arr[i] + <span class="string">&quot;\n&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">	str += uri</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对Authorization字段做Base64解码</span></span><br><span class="line">	signature := header.Get(<span class="string">&quot;Authorization&quot;</span>)</span><br><span class="line">	decodeSign, err := base64.StdEncoding.DecodeString(signature)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(<span class="string">&quot;解码失败&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;解码失败&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	log.Println(<span class="string">&quot;String2Sign:\t&quot;</span> + str)</span><br><span class="line"></span><br><span class="line">	hashed := sha1.Sum([]<span class="keyword">byte</span>(str))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 认证</span></span><br><span class="line">	<span class="keyword">return</span> rsa.VerifyPKCS1v15(publicKey, crypto.SHA1, hashed[<span class="number">0</span>:sha1.Size], decodeSign)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	header := <span class="built_in">make</span>(http.Header)</span><br><span class="line">	header.Set(<span class="string">&quot;Authorization&quot;</span>, <span class="string">&quot;Mko2Azg9fhCw8qR6G7AeAFMyzjO9qn7LDA5/t9E+6X5XURXTqBUuhpK+K55UNhrnlE2UdDkRrwDxsaDP5ajQdg==&quot;</span>)</span><br><span class="line">	header.Set(<span class="string">&quot;Content-md5&quot;</span>, <span class="string">&quot;M2ViOTE2ZDEyOTlkODBjMjVkNzM4YjNhNWI3ZWQ1M2E=&quot;</span>)</span><br><span class="line">	header.Set(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/xml;charset=utf-8&quot;</span>)</span><br><span class="line">	header.Set(<span class="string">&quot;Date&quot;</span>, <span class="string">&quot;Tue, 23 Feb 2016 09:41:06 GMT&quot;</span>)</span><br><span class="line">	header.Set(<span class="string">&quot;x-mns-request-id&quot;</span>, <span class="string">&quot;56CC2932F0E3D5BD530685CB&quot;</span>)</span><br><span class="line">	header.Set(<span class="string">&quot;x-mns-signing-cert-url&quot;</span>, <span class="string">&quot;aHR0cDovL21uc3Rlc3Qub3NzLWNuLWhhbmd6aG91LmFsaXl1bmNzLmNvbS94NTA5X3B1YmxpY19jZXJ0aWZpY2F0ZS5wZW0=&quot;</span>)</span><br><span class="line">	header.Set(<span class="string">&quot;x-mns-version&quot;</span>, <span class="string">&quot;2015-06-06&quot;</span>)</span><br><span class="line">	log.Println(AliNotification(<span class="string">&quot;POST&quot;</span>, <span class="string">&quot;/notifications&quot;</span>, header))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/21/APUE-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/default.png">
      <meta itemprop="name" content="zinego">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zinego's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/01/21/APUE-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/" class="post-title-link" itemprop="url">APUE 阅读笔记 第四章 文件和目录 第一部分</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-01-21 23:10:23" itemprop="dateCreated datePublished" datetime="2019-01-21T23:10:23+08:00">2019-01-21</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-31 12:16:22" itemprop="dateModified" datetime="2021-10-31T12:16:22+08:00">2021-10-31</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/APUE%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">APUE阅读笔记</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <pre><code>周六写的东西, 忘了发. 周日躺尸一天, 今天比较忙...... 未更新, 发布周六学习的内容
</code></pre>
<h2 id="第四章-文件和目录-第一部分"><a href="#第四章-文件和目录-第一部分" class="headerlink" title="第四章 文件和目录 第一部分"></a>第四章 文件和目录 第一部分</h2><h3 id="4-1-引言"><a href="#4-1-引言" class="headerlink" title="4.1 引言"></a>4.1 引言</h3><pre><code>1. 本章描述文件系统的其他特征和文件的性质
2. 了解文件的所有属性
3. 说明修改这个属性的各个函数
4. Unix文件系统的结构以及符号链接
5. 对目录进行操作的各个函数
6. 以降序便利目录层次结构的函数
</code></pre>
<h3 id="4-2-函数stat-fstat-fstatat-和lstat"><a href="#4-2-函数stat-fstat-fstatat-和lstat" class="headerlink" title="4.2 函数stat, fstat, fstatat, 和lstat"></a>4.2 函数stat, fstat, fstatat, 和lstat</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, struct stat* <span class="keyword">restrict</span> buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fstat</span><span class="params">(<span class="keyword">int</span> fd, struct stat *buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lstat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, struct stat * <span class="keyword">restrict</span> buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fstatat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, struct stat *<span class="keyword">restrict</span> buf, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">// 关于restrict: C语言中的一种类型限定符（Type Qualifiers），用于告诉编译器，</span></span><br><span class="line"><span class="comment">// 对象已经被指针所引用，不能通过除该指针外所有其他直接或间接的方式修改该对象的内容。</span></span><br></pre></td></tr></table></figure>

<p><strong>区别</strong></p>
<pre><code>stat函数返回与命名文件相关的信息结构
fstat函数获得已在描述符fd上打开文件的有关信息
lstat函数类似于stat, 但当命名文件是一个符号链接时,返回该链接信息, 而不是该链接指向的文件的信息
fstatat 函数为一个相对于当前打开目录(由fd指向)的路径名返回文件统计信息. 
</code></pre>
<p><strong>fstatat的flag</strong></p>
<pre><code>flag参数控制着是否跟随一个符号链接
AT_SYMLINK_NOFOLLOW标志被设置时, 不跟随.
否则跟随
如果fd参数的值AT_FDCWD, 
    1. pathname是相对路径, fstatat会计算对于当前目录的pathname参数.
    2. pathname是绝对路径, fd参数就会被忽略
</code></pre>
<p><strong>buf</strong></p>
<pre><code>函数通过填充buf来返回信息
</code></pre>
<h3 id="4-3-文件类型"><a href="#4-3-文件类型" class="headerlink" title="4.3 文件类型"></a>4.3 文件类型</h3><p><strong>普通文件</strong></p>
<pre><code>包含某种形式的数据. 
普通文本和二进制数据都是普通文件, 对Linux内核而言并无区别.
二进制可执行文件有特定的格式, 便于内核解析执行
</code></pre>
<p><strong>目录文件</strong></p>
<pre><code>包含其他文件的名字和指向这些文件有关信息的指针.
只有内核可以直接写目录文件, 进程必须使用函数来能更改目录
</code></pre>
<p><strong>块特殊文件</strong></p>
<pre><code>提供对设备带缓冲的访问, 每次访问以固定长度为单位进行
</code></pre>
<p><strong>字符特殊文件</strong></p>
<pre><code>提供对设备不带缓冲的访问,长度可变.
系统中的设备要么是字符特殊文件, 要么是块特殊文件
</code></pre>
<p><strong>FIFO</strong></p>
<pre><code>这种类型的文件用于进程间通信. 有时称之为命名管道
</code></pre>
<p><strong>套接字</strong></p>
<pre><code>用于进程间的网络通信, 也可用于一台主机进程之间的进程之间通信
</code></pre>
<p><strong>符号链接</strong></p>
<pre><code>用于指向另一个文件
文件类型信息存储在stat结构中的st_mode成员中. 
使用以下宏判断是文件类型
    1. S_ISBLK(m)       block special
    2. S_ISCHR(m)       char special
    3. S_ISDIR(m)       directory
    4. S_ISFIFO(m)    fifo or socket
    5. S_ISREG(m)       regular file
    6. S_ISLNK(m)       symbolic link
    7. S_ISSOCK(m)    socket
    8. S_TYPEISMQ(buf)        Test for a message queue
    9. S_TYPEISSEM(buf)    Test for a semaphore
    10. S_TYPEISSHM(buf)    Test for a shared memory object
</code></pre>
<h3 id="4-4-设置用户ID和设置组ID"><a href="#4-4-设置用户ID和设置组ID" class="headerlink" title="4.4 设置用户ID和设置组ID"></a>4.4 设置用户ID和设置组ID</h3><p><strong>与进程相关联的ID</strong></p>
<pre><code>1. 标识我们是谁
    - 实际用户ID
    - 实际组ID
2. 决定我们的文件的访问属性
    - 有效用户ID
    - 有效组ID
    - 附属组ID
3. 由exec函数保存
    - 保存的设置用户ID
    - 保存的设置组ID


通常, 进程的有效用户ID就是实际用户ID, 有效组ID通常是实际组ID
但是可以设置st_mode一个特殊标志, 含义是:
当执行此文件时, 进程的(有效用户ID/有效组ID)为文件所有者的(用户ID/组ID). `设置用户ID/组ID`
通过这种方式, 可以使普通用户获得root权限.
若文件所有者是超级用户, 并且设置了该文件的设置用户ID, 
那么当该程序文件由一个进程执行时, 该进程具有超级用户权限
</code></pre>
<p><strong>设置需谨慎</strong></p>
<pre><code>设置用户ID和设置组ID都包含在st_mode值中, 可以分别用s__ISUID和S_ISGID设置
</code></pre>
<h3 id="4-5-文件访问权限"><a href="#4-5-文件访问权限" class="headerlink" title="4.5 文件访问权限"></a>4.5 文件访问权限</h3><pre><code>st_mode值中包含了对文件(所有类型的文件)的访问权限位. 
每个文件有9个权限位: 
    1. 用户读/写/执行
    2. 组读/写/执行
    3. 其他读/写/执行
</code></pre>
<hr>
<p><strong>规则</strong></p>
<pre><code>1. 用任意名字打开任意类型的文件时, 需要对从文件所在的目录 -&gt; 根目录的所有目录都具有执行权限. 读权限允许我们读目录,获得在该目录下所有文件的列表.
2. 对一个文件的读权限决定了是否能够对当前文件进行读操作
3. 对一个文件的写权限决定了是否能够对当前文件进行写操作
4. 打开文件设置O_TRUNC必须对该文件具有写权限
5. 为了在目录中创建一个新文件, 必须对该目录具有执行权限和写权限
6. 为了删除一个现有的文件, 需要对目录具有写文件和执行权限, 对该文件本身不需要读写权限
7. 如果用7个exec函数中的任意一个执行某个文件, 必须对该文件有可执行权限, 文件必须是普通文件
</code></pre>
<hr>
<p><strong>权限检测</strong></p>
<pre><code>1. 检查进程的有效用户ID是否为0,
2. 进程的有效用户ID等于文件的所有者ID
3. 进程的有效组ID或进程的附属组ID等于文件的组ID
4. 其他用户
</code></pre>
<h3 id="4-6-新文件和目录的所有权"><a href="#4-6-新文件和目录的所有权" class="headerlink" title="4.6 新文件和目录的所有权"></a>4.6 新文件和目录的所有权</h3><pre><code>1. 新文件的用户ID设置为进程的有效用户ID. 
2. 新文件的组ID可以使进程的有效组ID
3. 新文件的组ID可以是它所在目录的组ID
</code></pre>
<h3 id="4-7-函数access和faccessat"><a href="#4-7-函数access和faccessat" class="headerlink" title="4.7 函数access和faccessat"></a>4.7 函数access和faccessat</h3><pre><code>当open函数打开一个文件时, 内核以进程的有效用户ID和有效组ID为基础执行其访问测试权限
但是, 有时进程也希望按实际用户ID和实际组ID来测试其访问功能.
access和faccessat函数就是满足这种需求的
</code></pre>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">access</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">faccessat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> mode, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">//成功返回0, 失败返回-1</span></span><br></pre></td></tr></table></figure>
<p><strong>mode</strong></p>
<pre><code>测试文件是否存在 F_OK
测试读权限 R_OK
测试写权限 W_OK
测试执行权限 X_OK
</code></pre>
<p><strong>异同</strong></p>
<pre><code>faccessat 函数和access函数在下面两种情况下是相同的.
1. pathname参数为绝对路径, 
2. fd参数取值为AT_FDCWD而pathname为相对路径
</code></pre>
<p><strong>flag</strong></p>
<pre><code>flag参数可以用以改变faccessat的行为, 如果flag设置为AT_EACCESS ,
访问检查用的是调用进程的有效用户ID和有效组ID, 而不是实际用户ID和实际组ID
</code></pre>
<h3 id="4-8-函数umask"><a href="#4-8-函数umask" class="headerlink" title="4.8 函数umask"></a>4.8 函数umask</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">mode_t</span> <span class="title">umask</span><span class="params">(<span class="keyword">mode_t</span> cmask)</span></span>;</span><br></pre></td></tr></table></figure>
<pre><code>umask函数为进程设置文件模式创建屏蔽字, 并返回之前的值
其中cmask是4.5中9个常量中的若干按位或构成的
在文件模式创建屏蔽字中为1的位, 文件中相应的为一定被关闭
测试代码如下:
</code></pre>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;apue.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">umask</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">creat</span>(<span class="string">&quot;foo&quot;</span>, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;creat error for foo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">umask</span>(S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">creat</span>(<span class="string">&quot;bar&quot;</span>, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;creat error for bar&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行之后, 发现foo是拥有rw-rw-rw-的权限的<br>但是umask屏蔽了<code>S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH</code> bar只有rw——-的权限</p>
<h3 id="4-9-函数chmod-fchmod-fchmodat"><a href="#4-9-函数chmod-fchmod-fchmodat" class="headerlink" title="4.9 函数chmod, fchmod, fchmodat"></a>4.9 函数chmod, fchmod, fchmodat</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chmod</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchmode</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchmodeat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode,<span class="keyword">int</span> flag)</span></span>;</span><br></pre></td></tr></table></figure>

<pre><code>chmod 在指定的文件上操作, fchmod在打开的文件上操作, 
fchmodat函数与chmod函数在下面两种情况下是相同的:
1. pathname参数是绝对路径, 
2. fd参数取值为AT_FDCWD, 而pathname为相对路径
flag参数可以改变fchmodeat的行为,当设置了AT_SYMLINK_NOFOLLOW标志时, fchmodeat并不会跟随符号链接
chmod只是更改i节点最近一次被修改的时间, ls -l列出的是最后修改文件内容的时间
</code></pre>
<p><strong>新增标志位</strong></p>
<pre><code>1. 执行时设置用户ID S_ISUID
2. 执行时设置组ID S_ISGID
3. 保存正文(粘着位) S_ISVTX
4. S_IRWXU  用户读写执行
5. S_IRWXG  组读写执行
6. S_IRWXO  其他读写执行
</code></pre>
<h3 id="4-10-粘着位"><a href="#4-10-粘着位" class="headerlink" title="4.10 粘着位"></a>4.10 粘着位</h3><pre><code>如果一个可执行文件的这一位被设置了, 那么当该程序第一次被执行, 
在其终止时, 程序正文部分(机器指令)的一个副本仍被保存在交换区.
使得下一次执行该程序时能够较快的将其装载入内存.
现在的系统扩展了粘着位的适用范围, Single Unix Specification允许针对目录设置粘着位.
如果对一个目录设置了粘着位, 只有对该目录具有写权限的用户且满足下列条件之一,
才能`删除`或者`重命名`该目录下的文件(但是可以新建文件呀)
1. 拥有该文件
2. 拥有此目录
3. 是超级用户
</code></pre>
<h3 id="4-11-函数chown-fchown-fchownat和lchown"><a href="#4-11-函数chown-fchown-fchownat和lchown" class="headerlink" title="4.11 函数chown, fchown, fchownat和lchown"></a>4.11 函数chown, fchown, fchownat和lchown</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chown</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchown</span><span class="params">(<span class="keyword">int</span> fd, uid_towner, <span class="keyword">gid_t</span> group)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchownat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lchown</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group)</span></span>;</span><br></pre></td></tr></table></figure>

<pre><code>他们的区别主要在于绝对路径与相对路径, 或者是改变符号链接或者符号链接指向的文件的所有者
</code></pre>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/17/APUE-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%96%87%E4%BB%B6I-O/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/default.png">
      <meta itemprop="name" content="zinego">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zinego's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/01/17/APUE-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%96%87%E4%BB%B6I-O/" class="post-title-link" itemprop="url">APUE 阅读笔记 第三章 文件I/O</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-01-17 21:02:12" itemprop="dateCreated datePublished" datetime="2019-01-17T21:02:12+08:00">2019-01-17</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-31 13:59:30" itemprop="dateModified" datetime="2021-10-31T13:59:30+08:00">2021-10-31</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/APUE%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">APUE阅读笔记</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="第三章-文件I-O"><a href="#第三章-文件I-O" class="headerlink" title="第三章 文件I/O"></a>第三章 文件I/O</h2><h3 id="3-1-引言"><a href="#3-1-引言" class="headerlink" title="3.1 引言"></a>3.1 引言</h3><pre><code>本章描述的函数通常被称为不带缓冲的I/O. 与第五章说明的标准I/O相对照.

术语不带缓冲指的是每个read和write都调用内核中的一个系统调用. 这些不带缓冲的I/O函数并不是ISO C的一部分. 但是它们是POSIX.1的组成部分
</code></pre>
<h3 id="3-2-文件描述符"><a href="#3-2-文件描述符" class="headerlink" title="3.2 文件描述符"></a>3.2 文件描述符</h3><pre><code>文件描述符0与进程的`标准输入`关联 -&gt; `STDIN_FILENO`
文件描述符1与进程的`标准输出`关联 -&gt; `STDOUT_FILENO`
文件描述符2与进程的`标准错误`关联 -&gt; `STDERR_FILENO`
文件描述符的变化范围是0~OPEN_MAX-1
</code></pre>
<h3 id="3-3-函数open和openat"><a href="#3-3-函数open和openat" class="headerlink" title="3.3 函数open和openat"></a>3.3 函数open和openat</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> oflag, ... <span class="comment">/* mode_t mode */</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">openat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> oflag,... <span class="comment">/* mode_t mode */</span>)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 两函数的返回值: 若成功,返回文件描述符, 若失败, 返回-1</span></span></span><br></pre></td></tr></table></figure>

<pre><code>path    是打开文件的路径
oflag   说明此函数的多个选项, 用或运算来构成oflag参数.
oflag 详情参加 APUE.50
</code></pre>
<hr>
<pre><code>由open和openat函数返回的文件描述符一定是最小的未用文件描述符数值. 这一点被应用程序用来在标准输入, 标准输出, 标准错误上面打开新的文件.

fd参数将open和openat函数区分开, 共有三种可能性:
1. path参数指定的是绝对路径名, 在这种情况下, fd参数可能被忽略, openat函数相当于open函数
2. path参数指定的是相对路径名, fd参数指出了相对路径名在文件系统的开始地址. fd参数是通过打开相对路径名所在的目录来获取.(相对路径是以开头是否&quot;/&quot;区分的. 如果是相对路径, 那么fd指向的必须是目录)
3. path参数指定了相对路径名, fd参数具有特殊值AT_FDCWD.在这种情况下, 路径名在 当前工作目录获取, openat函数在操作上与open函数类似.


将这两个函数分开,用来解决两个问题:
1. 同一进程的所有线程共享相同的当前目录, 因此很难让同一进程的多个不同线程在同一时间工作在不同的目录中.
2. 可以避免time-of-check-to-time-of-use问题
</code></pre>
<h3 id="3-4-函数create"><a href="#3-4-函数create" class="headerlink" title="3.4 函数create"></a>3.4 函数create</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">create</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>只写</strong></p>
<pre><code>create的不足之处是以只写方式打开文件的, 如果有读写的需求, 可以使用open组合flag来实现
</code></pre>
<h3 id="3-5-函数close"><a href="#3-5-函数close" class="headerlink" title="3.5 函数close"></a>3.5 函数close</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure>
<pre><code>关闭一个文件同时释放该进程加载该文件上的记录锁
当一个进程终止时, 内核自动关闭它打开的所有文件
</code></pre>
<h3 id="3-6-函数lseek"><a href="#3-6-函数lseek" class="headerlink" title="3.6 函数lseek"></a>3.6 函数lseek</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">off_t</span> <span class="title">lseek</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence)</span></span>;</span><br></pre></td></tr></table></figure>


<p><strong>文件偏移量</strong></p>
<pre><code>每个文件都会有一个与其相关联的`当前文件偏移量`. 通常是一个非负整数.
读写都从当前文件偏移处开始, 并使偏移量增加所读写的字节数
打开文件时, 文件偏移量为0
leeek 仅将当前文件偏移量记录在内核中, 并不引起任何I/O操作
</code></pre>
<hr>
<p><strong>whence</strong></p>
<pre><code>若whence=SEEK_SET, 则将该文件的偏移量设置为距离文件开始处offset个字节
若whence=SEEK_CUR, 则将该文件的偏移量设置为当前值加offset, offset可正可负
若whence=SEEK_END, 则将该文件的偏移量设置为距离文件长度+offset个字节,offset可正可负
成功执行, 返回新的文件偏移量
</code></pre>
<hr>
<p><strong>测试文件能否设置偏移量</strong></p>
<pre><code>如果文件描述符指向的是一个管道,FIFO, 或者网络套接字, 则lseek返回-1, 并将errno设置为ESPIPE.
</code></pre>
<hr>
<p><strong>文件空洞</strong></p>
<pre><code>文件空洞可以利用来多线程写
文件偏移量可以设置为大于当前文件的长度, 此时文件形成空洞. 空洞部分被读取为0. 
文件中的空洞并不在磁盘上占用存储区. 
(__书上是这么写的, 但是实际测试的时候, 发现空洞文件和普通文件占用的空间没什么不同......代码如下, 求解惑__)
</code></pre>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;apue.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf1[] = <span class="string">&quot;abcdefghij&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> buf2[] = <span class="string">&quot;ABCDEFGHIJ&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd ;</span><br><span class="line">    <span class="keyword">if</span> ((fd = <span class="built_in">creat</span>(<span class="string">&quot;file.hole&quot;</span>, FILE_MODE)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;create error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">write</span>(fd, buf1, <span class="number">10</span>) != <span class="number">10</span>)&#123;</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;buf1 write error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">lseek</span>(fd, <span class="number">16384</span>, SEEK_SET) == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;lseek error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">write</span>(fd, buf2, <span class="number">10</span>) != <span class="number">10</span>)&#123;</span><br><span class="line">        <span class="built_in">err_sys</span>(<span class="string">&quot;buf2 write error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *buf3 = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">16394</span>);</span><br><span class="line">    <span class="built_in">memset</span>(buf3, <span class="number">2</span>, <span class="number">16394</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fd = <span class="built_in">creat</span>(<span class="string">&quot;file.nohole&quot;</span>,FILE_MODE)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;create file error : &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">write</span>(fd, buf3, <span class="built_in">strlen</span>(buf3)) != <span class="built_in">strlen</span>(buf3))&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;write error : &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span> (buf3);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ls -ls file.hole file.nohole</span></span><br><span class="line"><span class="comment">//20 -rw-r--r-- 1 vagrant vagrant 16394 1月  18 15:00 file.hole</span></span><br><span class="line"><span class="comment">//20 -rw-r--r-- 1 vagrant vagrant 16394 1月  18 15:00 file.nohole</span></span><br><span class="line"><span class="comment">// 不明白为什么都是20 , 按书上讲的, 空洞文件应该是4才对...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//问题更新, 同样的文件, 放到/share下面是文件块大小是20, 放到home目录下是8 , why? </span></span><br></pre></td></tr></table></figure>


<h3 id="3-7-函数read"><a href="#3-7-函数read" class="headerlink" title="3.7 函数read"></a>3.7 函数read</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br></pre></td></tr></table></figure>
<pre><code>如果read成功, 则返回读取到的字节数. 如果已经到达文件尾端,返回0;
实际读取到的字节数少于要求读的字节数的情况: 
</code></pre>
<p><img src="/image/111.png"></p>
<h3 id="3-8-函数write"><a href="#3-8-函数write" class="headerlink" title="3.8 函数write"></a>3.8 函数write</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br></pre></td></tr></table></figure>
<pre><code>write 出错常见原因是磁盘已经写满, 或者超过了一个给定进程的文件长度限制
</code></pre>
<h3 id="3-9-I-O的效率"><a href="#3-9-I-O的效率" class="headerlink" title="3.9 I/O的效率"></a>3.9 I/O的效率</h3><pre><code>BUFSIZE的大小在4096字节以上比较好
</code></pre>
<h3 id="3-11-文件原子操作"><a href="#3-11-文件原子操作" class="headerlink" title="3.11 文件原子操作"></a>3.11 文件原子操作</h3><p><strong>问题提出</strong></p>
<pre><code>多线程对一个文件写时候, 如果A进程先进行lseek, CPU切换, B进程再进行lseek, 然后A进程写, B进程再写.
此时, A进程写的部分内容会被B进程覆盖掉
所以: 每个进程的lseek和写操作应该是原子的, 不能被打断.(打开文件时设置O_APPEND标志可线程安全的进行多文件末尾追加操作)
某扩展实现了pread和pwrite方法
</code></pre>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">pread</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes, <span class="keyword">off_t</span> offset)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">pwrite</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes, <span class="keyword">off_t</span> offset)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>特性</strong></p>
<pre><code>调用pread/pwrite时, 无法中断其定位和读操作
不更新当前文件偏移量
</code></pre>
<hr>
<p><strong>创建一个文件</strong></p>
<pre><code>在open一个文件时候同时指定O_CREAT和O_EXCL选项
此时将检查文件是否存在和创建文件这两个操作作为一个原子操作来执行.
</code></pre>
<h3 id="3-12-函数dup和dup2"><a href="#3-12-函数dup和dup2" class="headerlink" title="3.12 函数dup和dup2"></a>3.12 函数dup和dup2</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">int</span> fd2)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>两个函数的区别</strong></p>
<pre><code>由dup返回的新文件描述符一定是当前可用文件描述符中的最小数值.
对于dup2可以指定新的fd值. 如果fd2已经打开, 则先将其关闭. 
如果fd==fd2, 则dup2返回fd2, 并不关闭
这些函数返回的新文件描述符与参数fd共享一个文件表项
</code></pre>
<hr>
<p><strong>fcntl函数</strong></p>
<pre><code>复制文件描述符的方法还有另外一种方法: 
调用
    `dup(fd) `
等效于
    `fcntl(fd , F_DUPFD , 0);`
而调用
    dup2(fd, fd2);
等效于
    close(fd2)
    fcntl(fd,F_DUPFD, fd2)
</code></pre>
<p><strong>区别</strong></p>
<pre><code>1. 原子操作问题
2. 会有不同的errno
</code></pre>
<h3 id="3-13-sync-fsync和fdatasync"><a href="#3-13-sync-fsync和fdatasync" class="headerlink" title="3.13 sync, fsync和fdatasync"></a>3.13 sync, fsync和fdatasync</h3><pre><code>传统的UNIX系统实现在内核中设有缓冲区高速缓存或页高速缓存. 
大多数磁盘I/O都通过缓冲区来进行. 
当我们向文件写入数据时, 内核通常先将数据复制到缓冲区, 然后排入队列,晚些时候再写入磁盘.
为保证磁盘实际文件系统与缓冲区中的内容一致, UNIX提供以下函数
</code></pre>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsync</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fdatasync</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sync</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>区别</strong></p>
<pre><code>sync只是将所有修改过的块缓冲区排入到写队列, 然后就返回, 并不等待实际写磁盘操作结束
称为update的系统守护进程周期性的调用sync函数(30s).
fsync函数支队由文件描述符fd指定的一个文件有作用. 且等待写磁盘结束才返回.
fdatasync只同步文件的数据, fsync同步数据和文件属性
</code></pre>
<h3 id="3-14-函数fcntl"><a href="#3-14-函数fcntl" class="headerlink" title="3.14 函数fcntl"></a>3.14 函数fcntl</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, ... <span class="comment">/* int arg */</span>)</span></span></span><br></pre></td></tr></table></figure>
<pre><code>fcntl函数改变已经打开的文件的属性
1. 复制一个现有的描述符(cmd=F_DUPFD或F_DUPFD_CLOEXEC)。
2. 获得/设置文件描述符标记(cmd=F_GETFD或F_SETFD)。
3. 获得/设置文件状态标志(cmd=F_GETFL或F_SETFL)。
4. 获得/设置异步I/O所有权(cmd=F_GETOWN或F_SETOWN)。
5. 获得/设置记录锁(cmd=F_GETLK、F_SETLK或F_SETLKW)。
设置为F_DUPFD时,复制文件描述符, 返回值为大于等于第三个参数值的最小可用返回值
修改文件描述符标志或者文件状态标志时需要谨慎, 需要先获取当前值, 然后按照期望修改, 再设置新的标志值. 
</code></pre>
<h3 id="3-15-函数ioctl"><a href="#3-15-函数ioctl" class="headerlink" title="3.15 函数ioctl"></a>3.15 函数ioctl</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span> <span class="comment">/* System V */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span> <span class="comment">/* BSD Linux */</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ioctl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> request, ...,)</span></span>;</span><br></pre></td></tr></table></figure>





<h3 id="3-16-dev-fd"><a href="#3-16-dev-fd" class="headerlink" title="3.16 /dev/fd"></a>3.16 /dev/fd</h3><pre><code>较新的系统都提供/dev/fd目录, 其中是0,1,2,3之类的文件
某些系统提供/dev/stdin, /dev/stdout, /dev/stderr之类的文件, 等效于/dev/0, /dev/1, /dev/2
</code></pre>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/17/APUE-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E7%AB%A0-Unix%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/default.png">
      <meta itemprop="name" content="zinego">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zinego's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/01/17/APUE-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E7%AB%A0-Unix%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="post-title-link" itemprop="url">APUE 阅读笔记 第一章 Unix 基础知识</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-01-17 17:24:34" itemprop="dateCreated datePublished" datetime="2019-01-17T17:24:34+08:00">2019-01-17</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-31 12:16:22" itemprop="dateModified" datetime="2021-10-31T12:16:22+08:00">2021-10-31</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/APUE%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">APUE阅读笔记</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="第一章-Unix-基础知识"><a href="#第一章-Unix-基础知识" class="headerlink" title="第一章 Unix 基础知识"></a>第一章 Unix 基础知识</h2><h3 id="1-5-输入和输出"><a href="#1-5-输入和输出" class="headerlink" title="1.5 输入和输出"></a>1.5 输入和输出</h3><p><strong>不带缓冲的IO</strong></p>
<pre><code>头文件`&lt;unistd.h&gt;`以及两个常量`STDIN_FILENO`和`STDOUT_FILENO`都是POSIX的标准, 
其中`STDIN_FILENO`和`STDOUT_FILENO`的值分别为0和1
</code></pre>
<hr>
<p><strong>标准IO</strong></p>
<pre><code>标准IO函数为那些不带缓冲的IO函数提供了一个带缓冲的接口. 使用标准缓冲不用担心如何选取最佳的缓冲大小.
</code></pre>
<hr>
<h3 id="1-6-程序和进程"><a href="#1-6-程序和进程" class="headerlink" title="1.6 程序和进程"></a>1.6 程序和进程</h3><p><strong>程序</strong></p>
<pre><code>程序是一个存储在磁盘上某个目录中的可执行文件. 内核使用exec(_7个exec函数之一_)函数, 将程序放入内存, 并执行程序.
</code></pre>
<hr>
<p><strong>进程和进程ID</strong></p>
<pre><code>程序的执行实例被成为进程. 某些os用任务来表示正在被执行的程序
UNIX系统确保每个进程都有唯一的数字标识符, 成为进程ID, 是一个非负整数
</code></pre>
<hr>
<p><strong>进程控制</strong></p>
<p>有三个用于进程控制的主要函数: <code>fork</code>, <code>exec</code> ,<code>waitpid</code></p>
<p><code>int execlp(const char *file, const char *arg, ...);</code> </p>
<pre><code>从环境变量查找文件并执行
最后一个参数必须以空指针来结束, 一般而言, 空指针都是0 
将第二个参数之后的参数作为该文件的argv[0], argv[1]
</code></pre>
<p><code>pid_t waitpid(pid_t pid, int *status, int options);</code></p>
<pre><code>此函数会暂时停止目前进程的执行，直到有信号来到或子进程结束。
status 返回状态, 可以用一些其他的函数获取, 具体参加 `man waitpid`
创建子进程之后 , 失败的话, 向父进程返回值小于0 , 成功向父进程返回子进程id, 向子进程返回0
</code></pre>
<hr>
<p><strong>线程和线程id</strong></p>
<pre><code>通常, 一个进程只有一个控制线程---某一时刻执行的一组机器指令. 
一个进程的所有线程共享同一地址空间, 文件描述符, 栈以及进程相关的属性. 因为他们能访问同一存储区. 所以需要线程同步.
线程ID在另一个进程中没有意义
</code></pre>
<h3 id="1-7-出错处理"><a href="#1-7-出错处理" class="headerlink" title="1.7 出错处理"></a>1.7 出错处理</h3><pre><code>当UNIX系统函数出错时, 通常会返回一个负值, 而且整型变量errno通常被设置为具有特定信息的值
POSIX和ISO C将而将errno定义成一个符号, 它扩展成为一个可修改的整型左值. 
可以是一个可修改的整型左值, 也可以是一个返回出错编号的函数 
在支持线程的环境中, 每个线程都有属于他自己的局部errno以避免线程的干扰. 
可以使用strerror和平error函数来打印出错信息
</code></pre>
<hr>
<p><strong>出错恢复</strong></p>
<pre><code>可以将&lt;errno.h&gt;中定义的各种出错分成两类: 致命性的出错和非致命性的出错. 
对于致命性的错误, 无法执行恢复动作. 
对于非致命性的错误, 需要程序员妥善处理.
</code></pre>
<h3 id="1-8-用户标识"><a href="#1-8-用户标识" class="headerlink" title="1.8 用户标识"></a>1.8 用户标识</h3><p><strong>用户ID</strong></p>
<pre><code>口令文件登录项中的用户ID是一个数值, 它想系统标识各个不同的用户. 唯一且不能更改.
用户ID为0 == root
</code></pre>
<hr>
<p><strong>组ID</strong></p>
<pre><code>口令文件登录项也包括用户的组ID, 它是一个数值. 
组内成员共享文件, 而组外不能访问 
</code></pre>
<h3 id="1-9-信号"><a href="#1-9-信号" class="headerlink" title="1.9 信号"></a>1.9 信号</h3><pre><code>信号用来通知进程发成了某种情况. 例如: 若某一进程执行除法操作, 其除数为0, 则将名为SIGFPE的信号发送给该进程.
进程有一下三种处理信号的方式:
1. 忽略信号
2. 按系统默认方式处理
3. 提供一个函数, 信号发生时调用, 这种行为被称为捕捉信号.
</code></pre>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/15/rabbitmq%E5%AE%A2%E6%88%B7%E7%AB%AF-golang-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/default.png">
      <meta itemprop="name" content="zinego">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zinego's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/08/15/rabbitmq%E5%AE%A2%E6%88%B7%E7%AB%AF-golang-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5/" class="post-title-link" itemprop="url">rabbitmq客户端[golang]源码解析-建立连接</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-08-15 21:41:17" itemprop="dateCreated datePublished" datetime="2018-08-15T21:41:17+08:00">2018-08-15</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-31 13:59:30" itemprop="dateModified" datetime="2021-10-31T13:59:30+08:00">2021-10-31</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">消息队列</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="rabbitmq客户端-golang-源码解析"><a href="#rabbitmq客户端-golang-源码解析" class="headerlink" title="rabbitmq客户端(golang)源码解析"></a>rabbitmq客户端(golang)源码解析</h2><p><a target="_blank" rel="noopener" href="https://github.com/streadway/amqp">源码地址</a></p>
<h3 id="从建立连接开始"><a href="#从建立连接开始" class="headerlink" title="从建立连接开始"></a>从建立连接开始</h3><pre><code>消息流转过程如下
当客户端调用Dial(url)方法,解析url中的参数,并建立一条tcp连接,之后便开始消息流转
</code></pre>
<p><img src="/image/376.png" alt="Alt text"></p>
<h4 id="生成Connection"><a href="#生成Connection" class="headerlink" title="生成Connection"></a>生成Connection</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---------</span></span><br><span class="line"><span class="comment">Open accepts an already established connection, or other io.ReadWriteCloser as</span></span><br><span class="line"><span class="comment">a transport.  Use this method if you have established a TLS connection or wish</span></span><br><span class="line"><span class="comment">to use your own custom transport.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(conn io.ReadWriteCloser, config Config)</span> <span class="params">(*Connection, error)</span></span> &#123;</span><br><span class="line">    c := &amp;Connection&#123;</span><br><span class="line">        conn:      conn,</span><br><span class="line">        writer:    &amp;writer&#123;bufio.NewWriter(conn)&#125;, <span class="comment">//NewWriter创建一个具有默认大小缓冲、写入w的*Writer。</span></span><br><span class="line">        channels:  <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">uint16</span>]*Channel),</span><br><span class="line">        rpc:       <span class="built_in">make</span>(<span class="keyword">chan</span> message),</span><br><span class="line">        sends:     <span class="built_in">make</span>(<span class="keyword">chan</span> time.Time),</span><br><span class="line">        errors:    <span class="built_in">make</span>(<span class="keyword">chan</span> *Error, <span class="number">1</span>),</span><br><span class="line">        deadlines: <span class="built_in">make</span>(<span class="keyword">chan</span> readDeadliner, <span class="number">1</span>),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">go</span> c.reader(conn) <span class="comment">//这里读的是来自server的消息</span></span><br><span class="line">    <span class="keyword">return</span> c, c.open(config)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数生成一个连接对象,并进行参数初始化,conn是之前生成的tcp连接</p>
<h4 id="Protocol-Header-协议头帧的发送"><a href="#Protocol-Header-协议头帧的发送" class="headerlink" title="Protocol Header(协议头帧的发送)"></a>Protocol Header(协议头帧的发送)</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Connection)</span> <span class="title">open</span><span class="params">(config Config)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">//先写了协议头[amqp 0091]过去,后期调用的是protocolHeader.write方法</span></span><br><span class="line">    <span class="keyword">if</span> err := c.send(&amp;protocolHeader&#123;&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c.openStart(config)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个函数中,客户端发送了协议头帧,表面上看上去传入的是一个空的对象,但其中send中调用的是WriteFrame方法,WriteFrame方法中掉能用f.write方法,write方法是frame接口中的方法,protocolHeader实现了frame接口,实现的write方法如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(protocolHeader)</span> <span class="title">write</span><span class="params">(w io.Writer)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    _, err := w.Write([]<span class="keyword">byte</span>&#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;Q&#x27;</span>, <span class="string">&#x27;P&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">1</span>&#125;)</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出,此时写入的数据是<code>amqp0091</code></p>
<h4 id="接受来自服务端的命令"><a href="#接受来自服务端的命令" class="headerlink" title="接受来自服务端的命令"></a>接受来自服务端的命令</h4><p>可以看到,在生成Connection的代码中有这么一条语句<code>go c.reader(conn)</code><br>代码一直追踪下去可以看到下面的代码</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Connection)</span> <span class="title">demux</span><span class="params">(f frame)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> f.channel() == <span class="number">0</span> &#123;</span><br><span class="line">        c.dispatch0(f)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        c.dispatchN(f)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>f.channel()返回的是此时的ChannelID.显然,此时连接还未完全建立,channelID不可能存在,那么必然为0.那么我们看`dispatch0`方法
</code></pre>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// channel未创建时期的调用. 此时,channelid=0</span></span><br><span class="line"><span class="comment">// 将读取到的命令写入rpc(chan)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Connection)</span> <span class="title">dispatch0</span><span class="params">(f frame)</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> mf := f.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> *methodFrame:</span><br><span class="line">        <span class="keyword">switch</span> m := mf.Method.(<span class="keyword">type</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> *connectionClose:</span><br><span class="line">            <span class="comment">// Send immediately as shutdown will close our side of the writer.</span></span><br><span class="line">            c.send(&amp;methodFrame&#123;</span><br><span class="line">                ChannelId: <span class="number">0</span>,</span><br><span class="line">                Method:    &amp;connectionCloseOk&#123;&#125;,</span><br><span class="line">            &#125;)</span><br><span class="line">            c.shutdown(newError(m.ReplyCode, m.ReplyText))</span><br><span class="line">        <span class="keyword">case</span> *connectionBlocked:</span><br><span class="line">            <span class="keyword">for</span> _, c := <span class="keyword">range</span> c.blocks &#123;</span><br><span class="line">                c &lt;- Blocking&#123;Active: <span class="literal">true</span>, Reason: m.Reason&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> *connectionUnblocked:</span><br><span class="line">            <span class="keyword">for</span> _, c := <span class="keyword">range</span> c.blocks &#123;</span><br><span class="line">                c &lt;- Blocking&#123;Active: <span class="literal">false</span>&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            c.rpc &lt;- m</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">case</span> *heartbeatFrame:</span><br><span class="line">        <span class="comment">// kthx - all reads reset our deadline.  so we can drop this</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// lolwat - channel0 only responds to methods and heartbeats</span></span><br><span class="line">        c.closeWith(ErrUnexpectedFrame)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法中首先进行了类型推断,如果是方法帧,又对其进行了进一步处理.</p>
<ul>
<li>如果是Connection.Close: 那么此时直接返回Connection.CloseOk</li>
<li>如果是ConnectionBlocked:这个我也不清楚</li>
<li>如果是其他命令: 写入c.rpc管道中,等待进行进一步处理</li>
</ul>
<h4 id="Connection-Start"><a href="#Connection-Start" class="headerlink" title="Connection.Start"></a>Connection.Start</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Connection)</span> <span class="title">openStart</span><span class="params">(config Config)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    start := &amp;connectionStart&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> err := c.call(<span class="literal">nil</span>, start); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    c.Major = <span class="keyword">int</span>(start.VersionMajor)</span><br><span class="line">    c.Minor = <span class="keyword">int</span>(start.VersionMinor)</span><br><span class="line">    c.Properties = Table(start.ServerProperties)</span><br><span class="line">    c.Locales = strings.Split(start.Locales, <span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="comment">// eventually support challenge/response here by also responding to</span></span><br><span class="line">    <span class="comment">// connectionSecure.</span></span><br><span class="line">    auth, ok := pickSASLMechanism(config.SASL, strings.Split(start.Mechanisms, <span class="string">&quot; &quot;</span>))</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> ErrSASL</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Save this mechanism off as the one we chose</span></span><br><span class="line">    c.Config.SASL = []Authentication&#123;auth&#125;</span><br><span class="line">    <span class="comment">// Set the connection locale to client locale</span></span><br><span class="line">    c.Config.Locale = config.Locale</span><br><span class="line">    <span class="keyword">return</span> c.openTune(config, auth)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个方法中,首先使用c.call方法去接收来自服务端的Connection.Start命令,call方法的原型为<code>call func(req message, res ...message) error</code>,当req为nil时,直接从c.rpc中获取消息,并通过反射,将消息存入到start中,其中有来自服务端的一些参数.在此方法中仅进行接收Connection.Start命令并保存其中的一些参数的操作</p>
<h4 id="Connection-Tune"><a href="#Connection-Tune" class="headerlink" title="Connection.Tune"></a>Connection.Tune</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Connection)</span> <span class="title">openTune</span><span class="params">(config Config, auth Authentication)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(config.Properties) == <span class="number">0</span> &#123;</span><br><span class="line">        config.Properties = Table&#123;</span><br><span class="line">            <span class="string">&quot;product&quot;</span>: defaultProduct,</span><br><span class="line">            <span class="string">&quot;version&quot;</span>: defaultVersion,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    config.Properties[<span class="string">&quot;capabilities&quot;</span>] = Table&#123;</span><br><span class="line">        <span class="string">&quot;connection.blocked&quot;</span>:     <span class="literal">true</span>,</span><br><span class="line">        <span class="string">&quot;consumer_cancel_notify&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    ok := &amp;connectionStartOk&#123;</span><br><span class="line">        ClientProperties: config.Properties,</span><br><span class="line">        Mechanism:        auth.Mechanism(),</span><br><span class="line">        Response:         auth.Response(),</span><br><span class="line">        Locale:           config.Locale,</span><br><span class="line">    &#125;</span><br><span class="line">    tune := &amp;connectionTune&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> err := c.call(ok, tune); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// per spec, a connection can only be closed when it has been opened</span></span><br><span class="line">        <span class="comment">// so at this point, we know it&#x27;s an auth error, but the socket</span></span><br><span class="line">        <span class="comment">// was closed instead.  Return a meaningful error.</span></span><br><span class="line">        <span class="keyword">return</span> ErrCredentials</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// When the server and client both use default 0, then the max channel is</span></span><br><span class="line">    <span class="comment">// only limited by uint16.</span></span><br><span class="line">    <span class="comment">// 规定channel数量</span></span><br><span class="line">    c.Config.ChannelMax = pick(config.ChannelMax, <span class="keyword">int</span>(tune.ChannelMax))</span><br><span class="line">    <span class="keyword">if</span> c.Config.ChannelMax == <span class="number">0</span> &#123;</span><br><span class="line">        c.Config.ChannelMax = defaultChannelMax</span><br><span class="line">    &#125;</span><br><span class="line">    c.Config.ChannelMax = min(c.Config.ChannelMax, maxChannelMax)</span><br><span class="line">    <span class="comment">// Frame size includes headers and end byte (len(payload)+8), even if</span></span><br><span class="line">    <span class="comment">// this is less than FrameMinSize, use what the server sends because the</span></span><br><span class="line">    <span class="comment">// alternative is to stop the handshake here.</span></span><br><span class="line">    <span class="comment">//规定帧大小</span></span><br><span class="line">    c.Config.FrameSize = pick(config.FrameSize, <span class="keyword">int</span>(tune.FrameMax))</span><br><span class="line">    <span class="comment">// Save this off for resetDeadline()</span></span><br><span class="line">    c.Config.Heartbeat = time.Second * time.Duration(pick(</span><br><span class="line">        <span class="keyword">int</span>(config.Heartbeat/time.Second),</span><br><span class="line">        <span class="keyword">int</span>(tune.Heartbeat)))</span><br><span class="line">    <span class="comment">// &quot;The client should start sending heartbeats after receiving a</span></span><br><span class="line">    <span class="comment">// Connection.Tune method&quot;</span></span><br><span class="line">    <span class="keyword">go</span> c.heartbeater(c.Config.Heartbeat, c.NotifyClose(<span class="built_in">make</span>(<span class="keyword">chan</span> *Error, <span class="number">1</span>)))</span><br><span class="line">    <span class="keyword">if</span> err := c.send(&amp;methodFrame&#123;</span><br><span class="line">        ChannelId: <span class="number">0</span>,</span><br><span class="line">        Method: &amp;connectionTuneOk&#123;</span><br><span class="line">            ChannelMax: <span class="keyword">uint16</span>(c.Config.ChannelMax),</span><br><span class="line">            FrameMax:   <span class="keyword">uint32</span>(c.Config.FrameSize),</span><br><span class="line">            Heartbeat:  <span class="keyword">uint16</span>(c.Config.Heartbeat / time.Second),</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c.openVhost(config)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法同样调用c.call方法,但与openStart不同的是,请求参数是connectionStartOk结构,实际上是Connection.StartOK命令的体现,该结构在发送时携带用户名密码,在服务端进行身份验证,返回值是来自服务端的Connection.Tune命令.之后进行channelMax和帧大小等一些配置的设置,这些设置是跟服务端的参数一起约定的.之后便进行心跳检测.客户端将在收到Connection.Tune命令之后进行心跳检测.<br>然后还是调用send方法,将Connection.TuneOK的命令发送出去,命令中携带了最大帧大小,最大信道数,心跳频率的设置,相当于服务端把自己的配置发送客户端,客户端根据某种方式和自己的参数进行约定,之后把约定好的配置再返回给服务端</p>
<h4 id="Connection-Open"><a href="#Connection-Open" class="headerlink" title="Connection.Open"></a>Connection.Open</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Connection)</span> <span class="title">openVhost</span><span class="params">(config Config)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    req := &amp;connectionOpen&#123;VirtualHost: config.Vhost&#125;</span><br><span class="line">    res := &amp;connectionOpenOk&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> err := c.call(req, res); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// Cannot be closed yet, but we know it&#x27;s a vhost problem</span></span><br><span class="line">        <span class="keyword">return</span> ErrVhost</span><br><span class="line">    &#125;</span><br><span class="line">    c.Config.Vhost = config.Vhost</span><br><span class="line">    <span class="keyword">return</span> c.openComplete()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此方法相对来讲十分简单,不做赘述</p>
<h4 id="帧的读取"><a href="#帧的读取" class="headerlink" title="帧的读取"></a>帧的读取</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">0</span>      <span class="number">1</span>         <span class="number">3</span>             <span class="number">7</span>                  size+<span class="number">7</span> size+<span class="number">8</span></span><br><span class="line">  +------+---------+-------------+  +------------+  +-----------+</span><br><span class="line">  | <span class="keyword">type</span> | channel |     size    |  |  payload   |  | frame-end |</span><br><span class="line">  +------+---------+-------------+  +------------+  +-----------+</span><br><span class="line">   octet   short         long         size octets       octet</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *reader)</span> <span class="title">ReadFrame</span><span class="params">()</span> <span class="params">(frame frame, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> scratch [<span class="number">7</span>]<span class="keyword">byte</span></span><br><span class="line">    <span class="keyword">if</span> _, err = io.ReadFull(r.r, scratch[:<span class="number">7</span>]); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// ReadFull从r精确地读取len(buf)字节数据填充进buf。函数返回写入的字节数和错误（如果没有读取足够的字节）。只有没有读取到字节时才可能返回EOF；</span></span><br><span class="line">        <span class="comment">// 如果读取了有但不够的字节时遇到了EOF，函数会返回ErrUnexpectedEOF。 只有返回值err为nil时，返回值n才会等于len(buf)。</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    typ := <span class="keyword">uint8</span>(scratch[<span class="number">0</span>])</span><br><span class="line">    channel := binary.BigEndian.Uint16(scratch[<span class="number">1</span>:<span class="number">3</span>])</span><br><span class="line">    size := binary.BigEndian.Uint32(scratch[<span class="number">3</span>:<span class="number">7</span>])</span><br><span class="line">    <span class="keyword">switch</span> typ &#123;</span><br><span class="line">    <span class="keyword">case</span> frameMethod: <span class="comment">//方法帧</span></span><br><span class="line">        <span class="keyword">if</span> frame, err = r.parseMethodFrame(channel, size); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">case</span> frameHeader: <span class="comment">//内容头帧</span></span><br><span class="line">        <span class="keyword">if</span> frame, err = r.parseHeaderFrame(channel, size); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">case</span> frameBody: <span class="comment">//消息体帧</span></span><br><span class="line">        <span class="keyword">if</span> frame, err = r.parseBodyFrame(channel, size); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">case</span> frameHeartbeat: <span class="comment">//心跳帧</span></span><br><span class="line">        <span class="keyword">if</span> frame, err = r.parseHeartbeatFrame(channel, size); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, ErrFrame</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> _, err = io.ReadFull(r.r, scratch[:<span class="number">1</span>]); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> scratch[<span class="number">0</span>] != frameEnd &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, ErrFrame</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个帧的结构如下<br>[帧类型][信道编号][帧大小][方法帧][结束字节标记]<br>读取的时候,先读取7个字节的头部信息,其中包括一个字节的帧类型,两个字节的信道编号,四个字节的帧大小.<br>然后根据不同的的帧类型进行相应的处理<br>比如说,帧类型是方法帧,继续读出ClassID和Method,再根据编号判断出具体的方法,并进行进一步的处理<br>基本上知道帧的结构就很容易理解</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/15/AMQP%E5%B8%A7%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/default.png">
      <meta itemprop="name" content="zinego">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zinego's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/08/15/AMQP%E5%B8%A7%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">AMQP帧结构</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-08-15 21:00:01" itemprop="dateCreated datePublished" datetime="2018-08-15T21:00:01+08:00">2018-08-15</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-31 13:59:30" itemprop="dateModified" datetime="2021-10-31T13:59:30+08:00">2021-10-31</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">消息队列</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>524</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="AMQP帧结构"><a href="#AMQP帧结构" class="headerlink" title="AMQP帧结构"></a>AMQP帧结构</h3><ul>
<li>帧类型</li>
<li>信道编号</li>
<li>以字节为单位的帧大小</li>
<li>帧有效载荷</li>
<li>结束字节标记</li>
</ul>
<p><img src="/image/377.png"></p>
<h3 id="帧类型"><a href="#帧类型" class="headerlink" title="帧类型"></a>帧类型</h3><ul>
<li>协议头帧用于连接到rabbitmq,仅使用一次</li>
<li>方法帧携带发送给rabbitmq或从rabbitmq接收到的rpc请求或响应</li>
<li>内容头帧包含一条消息的大小和属性</li>
<li>消息体帧包含消息的内容</li>
<li>心跳帧在客户端与rabbitmq中进行传递,作为一种校验机制确保连接的两端都可用并且在正常工作</li>
</ul>
<h3 id="帧大小"><a href="#帧大小" class="headerlink" title="帧大小"></a>帧大小</h3><pre><code>amqp的帧有一个上限,如果消息体超过这个上限,消息内容将被拆分成多个消息体帧
方法帧和内容头帧中的数据是打包好的二进制数据,但消息体帧中的是未经处理的原消息内容
</code></pre>
<h3 id="方法帧结构"><a href="#方法帧结构" class="headerlink" title="方法帧结构"></a>方法帧结构</h3><pre><code>[帧类型][信道编号][帧大小][方法帧][结束字节标记]
[方法帧]=&gt;[basic][publish][交换器名称][路由键值][mandatory标志]
方法帧中包含请求所需的类,方法以及相关参数
</code></pre>
<h3 id="内容头帧"><a href="#内容头帧" class="headerlink" title="内容头帧"></a>内容头帧</h3><pre><code>[帧类型][信道编号][帧大小][内容头帧][结束字节标记]
[内容头帧]=&gt;[消息体大小][标志值][消息的内容属性][app_id][...][投递模式]
这里面的东西是Basic.Propertics的内容
</code></pre>
<h3 id="消息体帧"><a href="#消息体帧" class="headerlink" title="消息体帧"></a>消息体帧</h3><pre><code>[帧类型][信道编号][帧大小][消息体帧][结束字节标记]
[消息体帧]=&gt;[消息体]
</code></pre>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/24/Centos%E5%AE%89%E8%A3%85%E6%9C%80%E6%96%B0%E7%89%88RabbitMQ/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/default.png">
      <meta itemprop="name" content="zinego">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zinego's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/07/24/Centos%E5%AE%89%E8%A3%85%E6%9C%80%E6%96%B0%E7%89%88RabbitMQ/" class="post-title-link" itemprop="url">Centos安装最新版RabbitMQ</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-07-24 01:57:01" itemprop="dateCreated datePublished" datetime="2018-07-24T01:57:01+08:00">2018-07-24</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-31 12:16:22" itemprop="dateModified" datetime="2021-10-31T12:16:22+08:00">2021-10-31</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/" itemprop="url" rel="index"><span itemprop="name">软件安装</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="Centos安装最新版RabbitMQ"><a href="#Centos安装最新版RabbitMQ" class="headerlink" title="Centos安装最新版RabbitMQ"></a>Centos安装最新版RabbitMQ</h3><ol>
<li><p>安装依赖</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo yum update</span><br><span class="line">sudo yum install epel-release</span><br><span class="line">sudo yum install unixODBC unixODBC-devel wxBase wxGTK SDL wxGTK-gl</span><br><span class="line">sudo yum install socat.x86_64</span><br></pre></td></tr></table></figure></li>
<li><p>从<a target="_blank" rel="noopener" href="https://bintray.com/rabbitmq/rpm/erlang/21.0.3-1">这里</a>下载erlang安装软件<strong>不能从erlang官网下载,否则安装RabbitMQ出错</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://bintray.com/rabbitmq/rpm/download_file?file_path=erlang/21/el/7/x86_64/erlang-21.0.3-1.el7.centos.x86_64.rpm</span><br><span class="line">sudo rpm -ivh erlang-21.0.3-1.el7.centos.x86_64.rpm</span><br></pre></td></tr></table></figure></li>
<li><p>下载安装RabbitMQ</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://dl.bintray.com/rabbitmq/all/rabbitmq-server/3.7.7/rabbitmq-server-3.7.7-1.el7.noarch.rpm</span><br><span class="line">sudo rpm -ivh rabbitmq-server-3.7.7-1.el7.noarch.rpm</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="RabbitMQ-基础命令"><a href="#RabbitMQ-基础命令" class="headerlink" title="RabbitMQ 基础命令"></a>RabbitMQ 基础命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">启动RabbitMQ    rabbitmq-server -detached</span><br><span class="line">添加用户        rabbitmqctl add_user root password</span><br><span class="line">添加权限        rabbitmqctl set_permissions -p / root <span class="string">&quot;.*&quot;</span> <span class="string">&quot;.*&quot;</span> <span class="string">&quot;.*&quot;</span></span><br><span class="line">设置管理员      rabbitmqctl set_user_tags root administrator</span><br><span class="line">启用web管理     rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_management</span><br><span class="line">查看插件列表    rabbitmq-plugins list</span><br></pre></td></tr></table></figure>



<h3 id="搭建RabbitMQ集群"><a href="#搭建RabbitMQ集群" class="headerlink" title="搭建RabbitMQ集群"></a>搭建RabbitMQ集群</h3><h4 id="单机多节点"><a href="#单机多节点" class="headerlink" title="单机多节点"></a>单机多节点</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">启动多节点</span><br><span class="line"></span><br><span class="line">第一个节点:</span><br><span class="line">RABBITMQ_NODE_PORT=5681 RABBITMQ_NODENAME=rabbit1 RABBITMQ_SERVER_START_ARGS=<span class="string">&quot;-rabbitmq_management listener [&#123;port,15681&#125;]&quot;</span> rabbitmq-server -detached</span><br><span class="line"></span><br><span class="line">第二个节点</span><br><span class="line">RABBITMQ_NODE_PORT=5682 RABBITMQ_NODENAME=rabbit2 RABBITMQ_SERVER_START_ARGS=<span class="string">&quot;-rabbitmq_management listener [&#123;port,15682&#125;]&quot;</span> rabbitmq-server -detached</span><br><span class="line"></span><br><span class="line">第三个节点</span><br><span class="line">RABBITMQ_NODE_PORT=5683 RABBITMQ_NODENAME=rabbit3 RABBITMQ_SERVER_START_ARGS=<span class="string">&quot;-rabbitmq_management listener [&#123;port,15683&#125;]&quot;</span> rabbitmq-server -detached</span><br><span class="line"></span><br><span class="line">将节点添加到集群</span><br><span class="line">节点1</span><br><span class="line">rabbitmqctl -n rabbit1 stop_app</span><br><span class="line">rabbitmqctl -n rabbit1 reset</span><br><span class="line">rabbitmqctl -n rabbit1 join_cluster rabbit</span><br><span class="line">rabbitmqctl -n rabbit1 start_app</span><br><span class="line"></span><br><span class="line">节点2</span><br><span class="line">rabbitmqctl -n rabbit2 stop_app</span><br><span class="line">rabbitmqctl -n rabbit2 reset</span><br><span class="line">rabbitmqctl -n rabbit2 join_cluster rabbit</span><br><span class="line">rabbitmqctl -n rabbit2 start_app</span><br><span class="line"></span><br><span class="line">节点3</span><br><span class="line">rabbitmqctl -n rabbit3 stop_app</span><br><span class="line">rabbitmqctl -n rabbit3 reset</span><br><span class="line">rabbitmqctl -n rabbit3 join_cluster rabbit</span><br><span class="line">rabbitmqctl -n rabbit3 start_app</span><br><span class="line"></span><br><span class="line">还有节点rabbit,实际上相当于四个节点</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">查看节点信息</span><br><span class="line">rabbitmqctl -n rabbit cluster_status</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zinego</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">108k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">1:30</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdn.jsdelivr.net/npm/ribbon.js@1.0.2/dist/ribbon.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"zinego","repo":"zinego.github.io","client_id":"dea7eb7ad85f46bab6fe","client_secret":"6107f50af24e60f1ed4da39d44c70aa68e21a592","admin_user":"zinego","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","js":{"url":"https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js","integrity":"sha256-Pmj85ojLaPOWwRtlMJwmezB/Qg8BzvJp5eTzvXaYAfA="},"path_md5":"9d8d3da09189165dcde8f1d3e109ad78"}</script>
<script src="/js/third-party/comments/gitalk.js"></script>

</body>
</html>
