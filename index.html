<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">



















  
  
  
  

  
    
    
  

  
    
      
    

    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
    
    <link href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Noto Serif SC:300,300italic,400,400italic,700,700italic|Noto Serif SC:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.5.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.5.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.5.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.5.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="flyfish&#39;s blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="flyfish&#39;s blog">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="flyfish&#39;s blog">






  <link rel="canonical" href="http://yoursite.com/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>flyfish's blog</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title"><i class="fa fa-bookmark-o"></i>&nbsp;flyfish's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-schedule">

    
    
    
      
    

    

    <a href="/have-fun.html" rel="section"><i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>元素周期表</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/02/19/面试汇总-分布式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="flyfish">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/default.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="flyfish's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2021/02/19/面试汇总-分布式/" class="post-title-link" itemprop="http://yoursite.com/index.html">面试汇总-分布式</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2021-02-19 10:45:00" itemprop="dateCreated datePublished" datetime="2021-02-19T10:45:00+08:00">2021-02-19</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-02-28 17:49:14" itemprop="dateModified" datetime="2021-02-28T17:49:14+08:00">2021-02-28</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/面试/" itemprop="url" rel="index"><span itemprop="name">面试</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/02/18/面试汇总-Golang/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="flyfish">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/default.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="flyfish's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2021/02/18/面试汇总-Golang/" class="post-title-link" itemprop="http://yoursite.com/index.html">面试汇总-Golang</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2021-02-18 11:32:03" itemprop="dateCreated datePublished" datetime="2021-02-18T11:32:03+08:00">2021-02-18</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-03-01 08:53:19" itemprop="dateModified" datetime="2021-03-01T08:53:19+08:00">2021-03-01</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/面试/" itemprop="url" rel="index"><span itemprop="name">面试</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-协程调度的时机"><a href="#1-协程调度的时机" class="headerlink" title="1. 协程调度的时机"></a>1. 协程调度的时机</h3><ul>
<li>使用关键字go    </li>
<li>发生了GC</li>
<li>系统调用</li>
<li>内存同步访问</li>
</ul>
<h3 id="2-make和new的区别"><a href="#2-make和new的区别" class="headerlink" title="2. make和new的区别"></a>2. make和new的区别</h3><ul>
<li>make只适用于map/slice/channel, new用于内存分配, 并初始化零值</li>
<li>new不常用, make不可替代</li>
</ul>
<h3 id="3-数组和切片的区别"><a href="#3-数组和切片的区别" class="headerlink" title="3. 数组和切片的区别"></a>3. 数组和切片的区别</h3><ol>
<li>数组是值类型,  切片是引用类型</li>
<li>数组初始化时需要指定长度, 切片不需要</li>
<li>数组是定长的, 切片是变长的</li>
<li>数组是切片存储数据的底层结构. </li>
<li>数组的长度是类型的一部分, 长度为20 的数组和我长度为10 的数组不是一个类型. </li>
</ol>
<h3 id="4-Golang中有哪些引用类型"><a href="#4-Golang中有哪些引用类型" class="headerlink" title="4. Golang中有哪些引用类型"></a>4. Golang中有哪些引用类型</h3><ol>
<li>map</li>
<li>slice</li>
<li>channel</li>
<li>interface</li>
</ol>
<h3 id="5-map对于key的类型有什么要求"><a href="#5-map对于key的类型有什么要求" class="headerlink" title="5. map对于key的类型有什么要求"></a>5. map对于key的类型有什么要求</h3><blockquote>
<p>不能是函数类型、字典类型、切片类型。<br>原因：go语言规范规定，键类型的值之间必须可以施加==操作符和！=操作符，即必须支持判等操作，由于函数类型，字典类型，切片类型不支持判等操作</p>
</blockquote>
<h3 id="6-gpm模型"><a href="#6-gpm模型" class="headerlink" title="6. gpm模型"></a>6. gpm模型</h3><h3 id="7-context包的作用"><a href="#7-context包的作用" class="headerlink" title="7. context包的作用"></a>7. context包的作用</h3><blockquote>
<p>不同Goroutine之间同步信号.<br>携带上下文信息</p>
</blockquote>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/02/18/面试汇总-操作系统/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="flyfish">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/default.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="flyfish's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2021/02/18/面试汇总-操作系统/" class="post-title-link" itemprop="http://yoursite.com/index.html">面试汇总-操作系统</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2021-02-18 10:51:41" itemprop="dateCreated datePublished" datetime="2021-02-18T10:51:41+08:00">2021-02-18</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-03-14 16:31:38" itemprop="dateModified" datetime="2021-03-14T16:31:38+08:00">2021-03-14</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/面试/" itemprop="url" rel="index"><span itemprop="name">面试</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-进程和线程的区别"><a href="#1-进程和线程的区别" class="headerlink" title="1. 进程和线程的区别"></a>1. 进程和线程的区别</h3><ol>
<li>进程是资源分配的基本单位, 线程是CPU调度和执行的基本单位</li>
<li>进程内包含一到多个线程, 线程依赖于进程</li>
<li>同一进程的线程共享本进程的地址空间和资源, 而进程之间的地址空间和资源是相互独立的</li>
<li>每个进程都有独立的代码和数据空间(程序上下文), 程序之间的切换会有较大的开销；线程可以看做轻量级的进程, 同一类线程共享代码和数据空间, 每个线程都有自己独立的运行栈和程序计数器(PC), 线程之间切换的开销小. </li>
</ol>
<h3 id="2-死锁"><a href="#2-死锁" class="headerlink" title="2. 死锁"></a>2. 死锁</h3><p><code>死锁</code>: 是指两个或两个以上的进程在执行过程中, 因争夺资源而造成的一种互相等待的现象. (哲学家进餐问题)</p>
<h4 id="2-1-死锁的基本条件"><a href="#2-1-死锁的基本条件" class="headerlink" title="2.1 死锁的基本条件"></a>2.1 死锁的基本条件</h4><ol>
<li>互斥条件: 指进程对所分配到的资源进行排它性使用, 即在一段时间内某资源只由一个进程占用. 如果此时还有其它进程请求资源, 则请求者只能等待, 直至占有资源的进程用毕释放. </li>
<li>请求和保持条件: 指进程已经保持至少一个资源, 但又提出了新的资源请求, 此时请求进程阻塞, 但又对自己已获得的其它资源保持不放. 而该资源已被其它进程占有, </li>
<li>不剥夺条件: 指进程已获得的资源, 在未使用完之前, 不能被剥夺, 只能在使用完时由自己释放. </li>
<li>环路等待条件: 指在发生死锁时, 必然存在一个进程——资源的环形链, 即进程集合{P0, P1, P2, ···, Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源, ……, Pn正在等待已被P0占用的资源. </li>
</ol>
<h3 id="3-同步异步-阻塞非阻塞"><a href="#3-同步异步-阻塞非阻塞" class="headerlink" title="3. 同步异步/阻塞非阻塞"></a>3. 同步异步/阻塞非阻塞</h3><h4 id="3-1-同步和异步"><a href="#3-1-同步和异步" class="headerlink" title="3.1 同步和异步"></a>3.1 同步和异步</h4><ul>
<li>同步异步关注的是<code>消息通信机制</code>, 主要是被调用者(服务端).</li>
<li>同步: 在得到结果之前不返回. </li>
<li>异步: 得到结果之前返回, 得到结果之后再通知</li>
</ul>
<blockquote>
<p>你打电话问书店老板有没有《分布式系统》这本书, 如果是同步通信机制, 书店老板会说, 你稍等, ”我查一下”, 然后开始查啊查, 等查好了(可能是5秒, 也可能是一天)告诉你结果(返回结果).<br>而异步通信机制, 书店老板直接告诉你我查一下啊, 查好了打电话给你, 然后直接挂电话了(不返回结果). 然后查好了, 他会主动打电话给你. 在这里老板通过“回电”这种方式来回调. </p>
</blockquote>
<h4 id="3-2-阻塞和非阻塞"><a href="#3-2-阻塞和非阻塞" class="headerlink" title="3.2 阻塞和非阻塞"></a>3.2 阻塞和非阻塞</h4><ul>
<li>阻塞和非阻塞关注的是程序在等待调用结果(消息, 返回值)时的状态.</li>
<li>阻塞: 调用者在获得到返回值之前一直等待</li>
<li>非阻塞: 调用者在获得到返回值之前可以做别的事情. </li>
</ul>
<blockquote>
<p>你打电话问书店老板有没有《分布式系统》这本书, 你如果是阻塞式调用, 你会一直把自己“挂起”, 直到得到这本书有没有的结果,<br>如果是非阻塞式调用, 你不管老板有没有告诉你, 你自己先一边去玩了,  当然你也要偶尔过几分钟check一下老板有没有返回结果. </p>
</blockquote>
<h3 id="4-select-poll-epoll"><a href="#4-select-poll-epoll" class="headerlink" title="4. select/poll/epoll"></a>4. select/poll/epoll</h3><blockquote>
<p>摘自: <a href="https://blog.csdn.net/qq_36953135/article/details/77823893" target="_blank" rel="noopener">为什么epoll比select和poll更高效</a></p>
</blockquote>
<h4 id="4-1-select系统调用"><a href="#4-1-select系统调用" class="headerlink" title="4.1 select系统调用"></a>4.1 select系统调用</h4><p>select创建了3个文件描述符集(fd_set)并拷贝到内核中, 分别监听读、写、异常动作. select可以监听的文件描述符受到单个进程所能打开的fd的限制, 默认为1024.采用轮询方式, 遍历所有的fd, 最后返回一个文件描述符是否就绪的mask掩码, 并根据mask掩码给fd_set赋值. 将之前的fd_set拷贝传出到用户态并返回就绪的文件描述符的总个数. 用户态并不知道是哪些文件描述符处于就绪态, 需要遍历来判断. 应用程序索引就绪文件描述符的时间复杂度是O(n).再次调用select时, 需要将新的fd_set监听文件描述符拷贝传入进内核. select只能工作在相对较低下的LT模式</p>
<h4 id="4-2-poll系统调用"><a href="#4-2-poll系统调用" class="headerlink" title="4.2 poll系统调用"></a>4.2 poll系统调用</h4><p>将struct pollfd结构体数组拷贝到内核中进行监听. poll采用链表poll_list来进行文件描述符的存储, 因此poll可以监听的文件描述符数为系统可以打开的最大文件描述符数(65535). 采用轮询方式, 查询每个fd的状态, 如果就绪, 内核就修改fd对应的revents的值, 而events成员保持不变, 因此下次调用poll时, 应用程序无需重置pollfd类型的事件集参数. 将之前传入的struct pollfd结构体数组拷贝传出到用户态, 并返回就绪文件描述符的总个数. 用户态并不知道是哪些文件描述符处于就绪态, 需要遍历来判读. 应用程序索引就绪文件描述符的时间复杂度是O(n).poll只能工作在相对较低下的LT模式. </p>
<h4 id="4-3-epoll系统调用"><a href="#4-3-epoll系统调用" class="headerlink" title="4.3 epoll系统调用"></a>4.3 epoll系统调用</h4><p>执行epoll_create()函数会在内核创建一颗红黑树rb_node以及就绪链表rdllist(存放已经就绪的文件描述符), 监听的文件描述符数为系统可以打开的最大文件描述符数(65535). 接着用户执行的epoll_ctl()函数将epoll_event结构体拷贝传入内核, 内核会在红黑树上添加相应的结点, 并注册回调函数ep_poll_callback(), 内核在检测到某文件描述符可读/可写时就调用回调函数callback,该回调函数将文件描述符放入就绪链表rdllist中. epoll_wait()函数只需要观察rdllist中有无就绪的文件描述符即可, 内核将就绪的文件描述符事件复制到传入的poll_event结构体数组中返回给用户空间, 所以用户只用遍历依次处理即可, 即应用程序索引就绪文件描述符的时间复杂度是O(1). 这里返回的文件描述符是通过mmap让内核和用户空间共享同一块内存传递的, 减少了不必要的拷贝. 再次调用epoll系统调用, 不用重建红黑树, 直接沿用已经存在的即可. epoll支持ET模式, 当内核将该事件通知给用户后, 用户必须立即处理, 这样就减少了可读、可写和异常事件被触发的次数. </p>
<h4 id="4-4-为什么epoll更高效"><a href="#4-4-为什么epoll更高效" class="headerlink" title="4.4 为什么epoll更高效"></a>4.4 为什么epoll更高效</h4><ol>
<li>减少了内核态和用户态的拷贝</li>
<li>减少了对就绪文件描述符的遍历</li>
<li>select和poll只支持LT模式, 而epoll支持高效的ET模式, 并且epoll还支持EPOLLONESHOT事件. </li>
</ol>
<h4 id="4-5-EPOLL工作模式"><a href="#4-5-EPOLL工作模式" class="headerlink" title="4.5 EPOLL工作模式"></a>4.5 EPOLL工作模式</h4><ol>
<li>LT模式(电平触发): LT模式是默认的工作模式, 当检测到文件描述符上有事件发生并将此事件通知给应用程序, 应用程序可以不立即处理该事件, 下次调用会再次响应应用程序并通知此事件. </li>
<li>ET模式(边沿触发): 当检测到文件描述符上有事件发生并将此事件通知给应用程序, 应用程序必须立即处理该事件, 如果没处理或者没处理完, 下次调用不会再响应应用程序并通知此事件. <ul>
<li>ET模式很大程度上减少了epoll事件被重复触发的次数, 因此效率要比LT模式高, epoll工作在ET模式的时候, 必须使用非阻塞的套接字, 以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死. </li>
</ul>
</li>
<li>EPOLLONESHOT事件: 对于注册了EPOLLONESHOT事件的文件描述符, 操作系统最多触发其上的一个读、写或异常事件, 且只触发一次. 当一个线程在处理socket时, 其它线程是不可能有机会操作该socket的. 注册了EPOLLONESHOT事件的socket一旦被某个线程处理完, 该线程就应该立即重置这个socket上的EPOLLONESHOT事件, 以确保这个socket下次可读时, 其EPOLLIN事件可被触发, 进而让其它线程有机会处理这个socket. 使用EPOLLONESHOT事件能进一步减少可读、可写和异常事件的被触发的次数. </li>
</ol>
<h4 id="4-6-无论哪种情况下-epoll都比select和poll高效吗？"><a href="#4-6-无论哪种情况下-epoll都比select和poll高效吗？" class="headerlink" title="4.6 无论哪种情况下, epoll都比select和poll高效吗？"></a>4.6 无论哪种情况下, epoll都比select和poll高效吗？</h4><ol>
<li>epoll适用于连接较多, 活动数量较少的情况.  <ul>
<li>epoll为了实现返回就绪的文件描述符, 维护了一个红黑树和好多个等待队列, 内核开销很大. 如果此时监听了很少的文件描述符, 底层的开销会得不偿失；</li>
<li>epoll中注册了回调函数, 当有事件发生时, 服务器设备驱动调用回调函数将就绪的fd挂在rdllist上, 如果有很多的活动, 同一时间需要调用的回调函数数量太多, 服务器压力太大. </li>
</ul>
</li>
<li>select和poll适用于连接较少的情况.  <ul>
<li>当select和poll上监听的fd数量较少, 内核通知用户现在有就绪事件发生, 应用程序判断当前是哪个fd就绪所消耗的时间复杂度就会大大减小. </li>
</ul>
</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/02/13/面试汇总-网络/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="flyfish">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/default.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="flyfish's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2021/02/13/面试汇总-网络/" class="post-title-link" itemprop="http://yoursite.com/index.html">面试汇总-网络</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2021-02-13 15:14:53" itemprop="dateCreated datePublished" datetime="2021-02-13T15:14:53+08:00">2021-02-13</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-03-14 15:44:40" itemprop="dateModified" datetime="2021-03-14T15:44:40+08:00">2021-03-14</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/面试/" itemprop="url" rel="index"><span itemprop="name">面试</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一-TCP协议"><a href="#一-TCP协议" class="headerlink" title="一. TCP协议"></a>一. TCP协议</h2><h3 id="1-三次握手"><a href="#1-三次握手" class="headerlink" title="1. 三次握手"></a>1. 三次握手</h3><p>TCP/IP协议中, TCP协议提供可靠的连接服务, 采用三次握手建立一个连接, 如图1所示. </p>
<ol>
<li>第一次握手: 建立连接时, 客户端A发送SYN包(SYN=j)到服务器B, 并进入SYN_SEND状态, 等待服务器B确认. </li>
<li>第二次握手: 服务器B收到SYN包, 必须确认客户A的SYN(ACK=j+1), 同时自己也发送一个SYN包(SYN=k), 即SYN+ACK包, 此时服务器B进入SYN_RECV状态. </li>
<li>第三次握手: 客户端A收到服务器B的SYN＋ACK包, 向服务器B发送确认包ACK(ACK=k+1), 此包发送完毕, 客户端A和服务器B进入ESTABLISHED状态, 完成三次握手. </li>
</ol>
<p>完成三次握手, 客户端与服务器开始传送数据.<br><code>确认号</code>: 其数值等于发送方的发送序号 +1(即接收方期望接收的下一个序列号). </p>
<p><img src="/2021/02/13/面试汇总-网络/./TCPConnect.JPG" alt="enter image description here"></p>
<h3 id="2-四次挥手"><a href="#2-四次挥手" class="headerlink" title="2. 四次挥手"></a>2. 四次挥手</h3><p>TCP的连接的拆除需要发送四个包, 因此称为四次挥手(four-way handshake). 客户端或服务器均可主动发起挥手动作, 在socket编程中, 任何一方执行close()操作即可产生挥手操作. </p>
<ol>
<li>客户端A发送一个FIN, 用来关闭客户A到服务器B的数据传送.  </li>
<li>服务器B收到这个FIN, 它发回一个ACK, 确认序号为收到的序号加1. 和SYN一样, 一个FIN将占用一个序号.  </li>
<li>服务器B关闭与客户端A的连接, 发送一个FIN给客户端A.  </li>
<li>客户端A发回ACK报文确认, 并将确认序号设置为收到序号加1.  </li>
</ol>
<p><img src="/2021/02/13/面试汇总-网络/./08-59-13.jpg" alt="enter image description here"></p>
<h3 id="3-为什么是三次握手和四次挥手？"><a href="#3-为什么是三次握手和四次挥手？" class="headerlink" title="3. 为什么是三次握手和四次挥手？"></a>3. 为什么是三次握手和四次挥手？</h3><h4 id="3-1-为什么是三次握手？"><a href="#3-1-为什么是三次握手？" class="headerlink" title="3.1 为什么是三次握手？"></a>3.1 为什么是三次握手？</h4><blockquote>
<p>三次握手可以简单看做是客户发送请求, 服务器对客户的请求进行确认, 客户对服务器的确认再进行确认.<br>如果采用两次握手, 假设下面这种情况, 客户向服务器发送请求, 服务器没有对客户的请求进行确认(因为网络的延迟他可能没有收到这个请求). 客户收不到这个确认于是过一段时间他在向服务器发起连接请求并顺利完成数据传输, 但是过了一段时间这个请求到达了服务器而服务器误以为这是一个新的连接请求于是对这个请求进行确认并发送确认给客户但是客户没有发起过连接请求因此它不会理会服务器的确认, 服务器以为这个连接已经建立好了于是一直等待客户发送数据, 这样就会造成服务器的资源浪费. 如果采用三次握手上述情况客户不会向服务器的确认进行确认, 这样服务器收不到确认它就知道客户没有要发起请求的连接, 于是不会再等待.<br> 三次握手主要是为了防止已失效的连接请求报文突然到达服务器, 造成服务器的等待和资源的浪费. </p>
</blockquote>
<h4 id="3-2-为什么是四次挥手？"><a href="#3-2-为什么是四次挥手？" class="headerlink" title="3.2 为什么是四次挥手？"></a>3.2 为什么是四次挥手？</h4><blockquote>
<p>在三次握手的过程中, SYN和ACK是一起发送的但是在四次挥手的时候FIN和ACK却不是一起发送的而是分开发送的, 为什么呢？？？那是因为啊, TCP连接是全双工的也就是说接收到FIN只是说没有数据再发过来但是还是可以发送数据的, 也就是接受到一个FIN只是关闭了一个方向的数据传输, 另一个方向还可以继续发送数据. 在四次挥手的时候也是这样前两次挥手只是确认关闭了一个方向的数据, 加上后面两次挥手才真正的关闭了整个全双工连接.<br>当socket在ESTABISHED状态时, 他想主动关闭连接于是向对方发送FIN请求, 发送完FIN请求后它处于FIN_WAIT_1状态, 当对方确认ACK报文后则处于FIN_WAIT_2状态. FIN_WAIT_2表示半连接, 也就是有一方要求关闭连接, 另一方收到请求但是告诉她我还有一些数据要发送稍后会关闭. TIME_WAIT状态表示收到对方的FIN并发送出ACK.如果三次握手可能在关闭后还有一个方向没有关闭.<br>转载自: <a href="http://blog.csdn.net/yangliuhepanpan/article/details/51601221" target="_blank" rel="noopener">为什么是三次握手而不是两次握手为什么是四次挥手</a></p>
</blockquote>
<h3 id="4-深入理解TCP连接的释放"><a href="#4-深入理解TCP连接的释放" class="headerlink" title="4. 深入理解TCP连接的释放"></a>4. 深入理解TCP连接的释放</h3><p>由于TCP连接是全双工的, 因此每个方向都必须单独进行关闭. 这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接. 收到一个 FIN只意味着这一方向上没有数据流动, 一个TCP连接在收到一个FIN后仍能发送数据. 首先进行关闭的一方将执行主动关闭, 而另一方执行被动关闭.<br>TCP协议的连接是全双工连接, 一个TCP连接存在双向的读写通道.<br>简单说来是 “先关读, 后关写”, 一共需要四个阶段. 以客户机发起关闭连接为例: </p>
<ol>
<li>服务器读通道关闭</li>
<li>客户机写通道关闭</li>
<li>客户机读通道关闭</li>
<li>服务器写通道关闭<br>关闭行为是在发起方数据发送完毕之后, 给对方发出一个FIN(finish)数据段. 直到接收到对方发送的FIN, 且对方收到了接收确认ACK之后, 双方的数据通信完全结束, 过程中每次接收都需要返回确认数据段ACK. </li>
</ol>
<h4 id="4-1-连接释放详细过程"><a href="#4-1-连接释放详细过程" class="headerlink" title="4.1 连接释放详细过程"></a>4.1 连接释放详细过程</h4><p><strong>第一阶段</strong>   客户机发送完数据之后, 向服务器发送一个FIN数据段, 序列号为i;</p>
<ol>
<li>服务器收到FIN(i)后, 返回确认段ACK, 序列号为i+1, 关闭服务器读通道;</li>
<li>客户机收到ACK(i+1)后, 关闭客户机写通道;</li>
</ol>
<p>此时, 客户机仍能通过读通道读取服务器的数据, 服务器仍能通过写通道写数据,<br><strong>第二阶段</strong> 服务器发送完数据之后, 向客户机发送一个FIN数据段, 序列号为j;</p>
<ol>
<li>客户机收到FIN(j)后, 返回确认段ACK, 序列号为j+1, 关闭客户机读通道;</li>
<li>服务器收到ACK(j+1)后, 关闭服务器写通道.<br>这是标准的TCP关闭两个阶段, <code>服务器和客户机都可以发起关闭</code>, 完全对称. </li>
</ol>
<h3 id="5-TCP连接中出现的各种状态"><a href="#5-TCP连接中出现的各种状态" class="headerlink" title="5. TCP连接中出现的各种状态"></a>5. TCP连接中出现的各种状态</h3><p><code>SYN_RECV</code></p>
<blockquote>
<p>服务端收到建立连接的SYN没有收到ACK包的时候处在SYN_RECV状态. </p>
</blockquote>
<p><code>CLOSE_WAIT</code></p>
<blockquote>
<p>发起TCP连接关闭的一方称为client, 被动关闭的一方称为server. 被动关闭的server收到FIN后, 但未发出ACK的TCP状态是CLOSE_WAIT. 出现这种状况一般都是由于server端代码的问题, 如果你的服务器上出现大量CLOSE_WAIT, 应该要考虑检查代码. </p>
</blockquote>
<p><code>TIME_WAIT</code></p>
<blockquote>
<p>根据TCP协议定义的3次握手断开连接规定,发起socket主动关闭的一方 socket将进入TIME_WAIT状态. TIME_WAIT状态将持续2个MSL(Max Segment Lifetime),在Windows下默认为4分钟, 即240秒. TIME_WAIT状态下的socket不能被回收使用. 具体现象是对于一个处理大量短连接的服务器,如果是由服务器主动关闭客户端的连接, 将导致服务器端存在大量的处于TIME_WAIT状态的socket,  甚至比处于Established状态下的socket多的多,严重影响服务器的处理能力, 甚至耗尽可用的socket, 停止服务.<br><code>TIME_WAIT是TCP协议用以保证被重新分配的socket不会受到之前残留的延迟重发报文影响的机制,是必要的逻辑保证</code></p>
</blockquote>
<p>转载自: <a href="http://www.cnblogs.com/Jessy/p/3535612.html" target="_blank" rel="noopener">TCP的三次握手(建立连接)和四次挥手(关闭连接)</a></p>
<h3 id="6-TCP和UDP的区别"><a href="#6-TCP和UDP的区别" class="headerlink" title="6. TCP和UDP的区别"></a>6. TCP和UDP的区别</h3><ol>
<li>基于连接与无连接</li>
<li>TCP要求系统资源较多, UDP较少</li>
<li>UDP程序结构较简单 </li>
<li>流模式(TCP)与数据报模式(UDP)</li>
<li>TCP保证数据正确性, UDP可能丢包 </li>
<li>TCP保证数据顺序, UDP不保证 </li>
<li>TCP更慢, UDP更快</li>
</ol>
<h3 id="7-TCP如何保证可靠性"><a href="#7-TCP如何保证可靠性" class="headerlink" title="7. TCP如何保证可靠性"></a>7. TCP如何保证可靠性</h3><blockquote>
<p>参考: <a href="https://blog.csdn.net/liuchenxia8/article/details/80428157" target="_blank" rel="noopener">TCP协议-如何保证传输可靠性</a></p>
</blockquote>
<ul>
<li>校验和</li>
<li>序列号</li>
<li>确认应答</li>
<li>超时重传</li>
<li>连接管理</li>
<li>流量控制: 受到接收端窗口大小影响</li>
<li>拥塞控制: 受到网络带宽影响</li>
</ul>
<h3 id="8-慢启动-拥塞避免"><a href="#8-慢启动-拥塞避免" class="headerlink" title="8. 慢启动, 拥塞避免"></a>8. 慢启动, 拥塞避免</h3><p><img src="/2021/02/13/面试汇总-网络/./20150419112344942" alt="enter image description here"><br><img src="/2021/02/13/面试汇总-网络/./20150419131338193" alt="enter image description here"></p>
<ol>
<li>开始发送数据时, 窗口较小</li>
<li>未达到阈值时, 窗口大小以指数级增长</li>
<li>达到阈值时, 窗口大小线性增长</li>
<li>发生超时重传时, 慢启动阈值会变成之前窗口大小的一半, 而此时的窗口大小为初始值. </li>
</ol>
<h3 id="9-快重传和快恢复"><a href="#9-快重传和快恢复" class="headerlink" title="9. 快重传和快恢复"></a>9. 快重传和快恢复</h3><h4 id="9-1-快重传"><a href="#9-1-快重传" class="headerlink" title="9.1 快重传"></a>9.1 快重传</h4><p><img src="/2021/02/13/面试汇总-网络/./aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzAxMTE1MzUyMjgx" alt="enter image description here"></p>
<ol>
<li>要求接收方每收到一个失序的报文段后就立即发出重复确认而不是等待自己发送数据时才捎带确认</li>
<li>发送方只要一连收到三个重复确认就立即重传对方尚未收到的报文段, 而不必等待设置的重传计时器到期</li>
</ol>
<h4 id="9-2-快恢复"><a href="#9-2-快恢复" class="headerlink" title="9.2 快恢复"></a>9.2 快恢复</h4><p><img src="/2021/02/13/面试汇总-网络/./20150419131338193" alt="enter image description here"></p>
<ol>
<li>当发送方连续收到三个重复确认时, 就执行“乘法减小”算法, 把慢开始门限ssthresh减半, 为了预防网络拥塞</li>
<li>将拥塞窗口cwnd值设置为慢开始门限ssthresh减半后的数值, 然后开始执行拥塞避免算法</li>
</ol>
<ul>
<li>TCP Tahoe版本与TCP Reno版本的区别: Reno版本在快重传之后采用快恢复算法而不是采用慢开始算法</li>
</ul>
<h3 id="10-为什么需要TIME-WAIT状态"><a href="#10-为什么需要TIME-WAIT状态" class="headerlink" title="10. 为什么需要TIME_WAIT状态"></a>10. 为什么需要<code>TIME_WAIT</code>状态</h3><ul>
<li>防止延迟的数据段被其他使用相同源地址、源端口、目的地址以及目的端口的 TCP 连接收到;</li>
<li>保证 TCP 连接的远程被正确关闭, 即等待被动关闭连接的一方收到 FIN 对应的 ACK 消息;</li>
</ul>
<p>详情见: <a href="https://draveness.me/whys-the-design-tcp-time-wait/" target="_blank" rel="noopener">为什么 TCP 协议有 TIME_WAIT 状态</a></p>
<h2 id="二-HTTP协议"><a href="#二-HTTP协议" class="headerlink" title="二. HTTP协议"></a>二. HTTP协议</h2><h3 id="1-HTTPS-TLS的握手过程"><a href="#1-HTTPS-TLS的握手过程" class="headerlink" title="1. HTTPS TLS的握手过程"></a>1. HTTPS TLS的握手过程</h3><h4 id="1-1-TLS-单行认证握手"><a href="#1-1-TLS-单行认证握手" class="headerlink" title="1.1 TLS 单行认证握手"></a>1.1 TLS 单行认证握手</h4><p><img src="/2021/02/13/面试汇总-网络/./14158ca87e2f341ff044efd967f3e008.png" alt="enter image description here"></p>
<ol>
<li>客户端给出协议版本号、一个客户端生成的随机数(Client random), 以及客户端支持的加密方法. </li>
<li>服务端确认双方使用的加密方法, 并给出数字证书、以及一个服务器生成的随机数(Server random)</li>
<li>客户端确认数字证书有效, 然后生成一个新的随机数(Premaster secret), 并使用数字证书中的公钥, 加密这个随机数, 发给服务端. </li>
<li>服务端使用自己的私钥, 获取客户端发来的随机数(即Premaster secret). </li>
<li>客户端和服务端根据约定的加密方法, 使用前面的三个随机数, 生成<code>对话密钥</code>(session key), 用来加密接下来的整个对话过程. </li>
</ol>
<h4 id="1-2-为什么需要三个随机数"><a href="#1-2-为什么需要三个随机数" class="headerlink" title="1.2 为什么需要三个随机数"></a>1.2 为什么需要三个随机数</h4><p><strong>增强随机性.</strong></p>
<blockquote>
<p>不管是客户端还是服务器, 都需要随机数, 这样生成的密钥才不会每次都一样. 由于SSL协议中证书是静态的, 因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性.<br>对于RSA密钥交换算法来说, pre-master-key本身就是一个随机数, 再加上hello消息中的随机, 三个随机数通过一个密钥导出器最终导出一个对称密钥.<br>pre master的存在在于SSL协议不信任每个主机都能产生完全随机的随机数, 如果随机数不随机, 那么pre master secret就有可能被猜出来, 那么仅适用pre master secret作为密钥就不合适了, 因此必须引入新的随机因素, 那么客户端和服务器加上pre master secret三个随机数一同生成的密钥就不容易被猜出了, 一个伪随机可能完全不随机, 可是是三个伪随机就十分接近随机了, 每增加一个自由度, 随机性增加的可不是一. </p>
</blockquote>
<h4 id="1-2-TLS-双向认证握手"><a href="#1-2-TLS-双向认证握手" class="headerlink" title="1.2 TLS 双向认证握手"></a>1.2 TLS 双向认证握手</h4><p><img src="/2021/02/13/面试汇总-网络/./08e6235892053a81603a4c3d7c7f44ad.png" alt="enter image description here"></p>
<ul>
<li>客户端发起请求, 给出协议版本号</li>
<li>客户端/服务端交换证书</li>
<li>客户端发送客户端支持的加密方案</li>
<li>服务端根据自己的情况, 选择<code>加密方案</code>, 使用客户端的公钥加密, 返回给客户端</li>
<li>客户端用自己私钥解密<code>加密方案</code>,  生成随机数(<code>对话秘钥</code>), 使用服务端的公钥加密, 发送给服务端</li>
<li>服务端使用自己的私钥解密, 解析出随机数(<code>对话秘钥</code>)</li>
</ul>
<h3 id="2-session的恢复"><a href="#2-session的恢复" class="headerlink" title="2. session的恢复"></a>2. session的恢复</h3><p>握手阶段用来建立SSL连接. 如果出于某种原因, 对话中断, 就需要重新握手. </p>
<ul>
<li>session ID: 每一次对话都有一个编号(session ID). 如果对话中断, 下次重连的时候, 只要客户端给出这个编号, 且服务器有这个编号的记录, 双方就可以重新使用已有的”对话密钥”, 而不必重新生成一把. <ul>
<li>缺点: 换个服务器就不认. </li>
</ul>
</li>
<li>session ticket: 将本次对话的主要信息, 比如对话密钥和加密方法加密, 只有服务器才能解密(应该是公钥加密). 当服务器收到session ticket以后, 解密后就不必重新生成对话密钥了. </li>
</ul>
<h3 id="3-HTTPS-对于HTTP解决了什么问题"><a href="#3-HTTPS-对于HTTP解决了什么问题" class="headerlink" title="3. HTTPS 对于HTTP解决了什么问题"></a>3. HTTPS 对于HTTP解决了什么问题</h3><ol>
<li>窃听风险(eavesdropping): 第三方可以获知通信内容. (没有对话秘钥无法解析)</li>
<li>篡改风险(tampering): 第三方可以修改通信内容.  (篡改后的数据, 无法通过对话秘钥解析)</li>
<li>冒充风险(pretending): 第三方可以冒充他人身份参与通信.  (同2)</li>
</ol>
<h3 id="4-如何保证公钥不被篡改"><a href="#4-如何保证公钥不被篡改" class="headerlink" title="4. 如何保证公钥不被篡改"></a>4. 如何保证公钥不被篡改</h3><blockquote>
<p>放入数字证书中, 数字证书是有效的, 公钥就是有效的. 数字证书由数字证书机构(CA)颁发.</p>
</blockquote>
<h3 id="5-怎么减少公钥加解密的时间"><a href="#5-怎么减少公钥加解密的时间" class="headerlink" title="5. 怎么减少公钥加解密的时间"></a>5. 怎么减少公钥加解密的时间</h3><blockquote>
<p>每一次对话(session), 客户端和服务器端都生成一个”对话密钥”（session key), 用它来加密信息. 由于”对话密钥”是对称加密, 所以运算速度非常快, 而服务器公钥只用于加密”对话密钥”本身, 这样就减少了加密运算的消耗时间.<br>然后尽量复用连接</p>
</blockquote>
<h3 id="6-HTTPS和HTTP的区别"><a href="#6-HTTPS和HTTP的区别" class="headerlink" title="6. HTTPS和HTTP的区别"></a>6. HTTPS和HTTP的区别</h3><ol>
<li>HTTPS安全, HTTP基于明文传输, 不安全</li>
<li>HTTPS性能下降, 主要体现在, 建立连接增加了tls握手, 发送接收数据需要加解密</li>
<li>端口不一样</li>
<li>SSL证书要钱</li>
</ol>
<h3 id="7-HTTP2和HTTP的区别"><a href="#7-HTTP2和HTTP的区别" class="headerlink" title="7. HTTP2和HTTP的区别"></a>7. HTTP2和HTTP的区别</h3><ul>
<li>HTTP/2 使用<code>HPACK</code>算法压缩头部信息, 消除冗余数据节约带宽;</li>
<li>HTTP/2 的消息不再是<code>Header+Body</code>的形式, 而是分散为多个二进制<code>帧</code>; </li>
<li>HTTP/2 使用虚拟的<code>流</code>传输消息, 解决了困扰多年的<code>队头阻塞</code>问题, 同时实现了<code>多路复用</code>, 提高连接的利用率; (怎么保证有序: 帧里面有流标识符. 还有流ID)</li>
<li>HTTP/2 也增强了安全性, 要求至少是 TLS1.2, 而且禁用了很多不安全的密码套件. </li>
</ul>
<h3 id="8-队头阻塞问题"><a href="#8-队头阻塞问题" class="headerlink" title="8. 队头阻塞问题"></a>8. 队头阻塞问题</h3><ul>
<li>TCP队头阻塞: 上一个报文没有成功发送出去, 后续的报文都会被阻塞</li>
<li>HTTP队头阻塞: 服务端按照请求发送的顺序返回响应（FIFO），原因很简单，HTTP请求和响应并没有序号标识，无法将乱序的响应与请求关联起来。</li>
</ul>
<h2 id="last-参考资料"><a href="#last-参考资料" class="headerlink" title="last. 参考资料"></a>last. 参考资料</h2><ul>
<li><a href="http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html" target="_blank" rel="noopener">数字签名是什么？</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">SSL/TLS协议运行机制的概述</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html" target="_blank" rel="noopener">图解SSL/TLS协议</a></li>
<li><a href="https://developer.aliyun.com/article/726414" target="_blank" rel="noopener">HTTPS双向认证研究</a></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/02/13/面试汇总-数据库/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="flyfish">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/default.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="flyfish's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2021/02/13/面试汇总-数据库/" class="post-title-link" itemprop="http://yoursite.com/index.html">面试汇总-数据库</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2021-02-13 15:14:40" itemprop="dateCreated datePublished" datetime="2021-02-13T15:14:40+08:00">2021-02-13</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-03-01 08:53:50" itemprop="dateModified" datetime="2021-03-01T08:53:50+08:00">2021-03-01</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/面试/" itemprop="url" rel="index"><span itemprop="name">面试</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-索引失效的几种场景"><a href="#1-索引失效的几种场景" class="headerlink" title="1. 索引失效的几种场景"></a>1. 索引失效的几种场景</h3><ol>
<li>使用了函数, 或者计算.</li>
<li>前缀模糊查询， 即 like %**</li>
<li>数据类型不一致问题。 即查询的类型和数据库定义的字段类型不一致</li>
<li>使用了非等值查询。</li>
<li>没有匹配上最左匹配原则</li>
<li>使用了or查询</li>
</ol>
<h3 id="2-什么是两阶段提交"><a href="#2-什么是两阶段提交" class="headerlink" title="2. 什么是两阶段提交"></a>2. 什么是两阶段提交</h3><p><img src="/2021/02/13/面试汇总-数据库/./5ae7d074c34bc5bd55c82781de670c28.png" width="50%"></p>
<ol>
<li>写入redo log, redo log 处于prepare状态</li>
<li>写入binlog</li>
<li>redo log处于commit状态</li>
</ol>
<!-- ![enter image description here](./5ae7d074c34bc5bd55c82781de670c28.png?100x) -->
<h4 id="2-1-为什么需要两阶段提交"><a href="#2-1-为什么需要两阶段提交" class="headerlink" title="2.1 为什么需要两阶段提交"></a>2.1 为什么需要两阶段提交</h4><blockquote>
<p>保证用binlog恢复回来的库(从库, 备份库)与用redo log恢复的库的数据一致.<br>假如先写redo log , 再写binlog, 那么中间宕机会导致binlog恢复出来的库数据少.<br>假如先写binlog, 在写redo log, 那么中间宕机会导致redo log 恢复出来的库数据少. </p>
</blockquote>
<h4 id="2-2-能不能只用redo-log"><a href="#2-2-能不能只用redo-log" class="headerlink" title="2.2 能不能只用redo log"></a>2.2 能不能只用redo log</h4><p>不能, 因为binlog提供归档/下游消费/主从同步等功能. </p>
<h4 id="2-3-能不能只用binlog"><a href="#2-3-能不能只用binlog" class="headerlink" title="2.3 能不能只用binlog"></a>2.3 能不能只用binlog</h4><p>不能, 因为redo log 仅记录了未写入磁盘的数据. binlog 记录的是所有的数据. </p>
<h3 id="3-redolog-binlog-undolog"><a href="#3-redolog-binlog-undolog" class="headerlink" title="3. redolog/binlog/undolog"></a>3. redolog/binlog/undolog</h3><ul>
<li><code>redolog</code>: 确保事务的持久性。防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的持久性这一特性。</li>
<li><code>binlog</code>: 用于复制，在主从复制中，从库利用主库上的binlog进行重播，实现主从同步。用于数据库的基于时间点的还原。</li>
<li><code>undolog</code>: 每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。 <ul>
<li>什么时候删除: 当没有事务比这个回滚日志更早的read-view时</li>
</ul>
</li>
</ul>
<h3 id="4-什么是多版本并发控制-怎么实现"><a href="#4-什么是多版本并发控制-怎么实现" class="headerlink" title="4. 什么是多版本并发控制, 怎么实现."></a>4. 什么是多版本并发控制, 怎么实现.</h3><blockquote>
<p>同一条记录在系统中存在不同版本的值.</p>
</blockquote>
<h4 id="4-1-事务的一致性视图"><a href="#4-1-事务的一致性视图" class="headerlink" title="4.1 事务的一致性视图"></a>4.1 事务的一致性视图</h4><blockquote>
<p>InnoDB 里面每个事务有一个唯一的事务 ID，叫作 transaction id。它是在事务开始的时候向 InnoDB 的事务系统申请的，是按申请顺序严格递增的。<br>每条数据存在多个版本(undolog), 每个版本会记录更新该版本的事务ID: row_trx_id<br>InnoDB 为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务 ID。“活跃”指的就是，启动了但还没提交。<br>数组里面事务 ID 的最小值记为低水位，当前系统里面已经创建过的事务 ID 的最大值加 1 记为高水位。<br>这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）。<br>如果事务ID大于高水平, 那么一定不可见<br>如果事务ID小于低水平, 那么一定可见<br>如果事务ID在高水平和低水平之间, 且该事务ID在数组里面, 说明不可见, 否则可见. </p>
</blockquote>
<h3 id="5-为什么会出现主备延迟"><a href="#5-为什么会出现主备延迟" class="headerlink" title="5. 为什么会出现主备延迟"></a>5. 为什么会出现主备延迟</h3><ol>
<li>备库的性能比主库差</li>
<li>备库的压力大, 读操作更多</li>
<li>大事务</li>
<li>并行复制: 之前备库都是单线程消费binlog. </li>
</ol>
<h3 id="6-能不能用连表查询"><a href="#6-能不能用连表查询" class="headerlink" title="6. 能不能用连表查询"></a>6. 能不能用连表查询</h3><ol>
<li>如果可以使用被驱动表的索引, 那么可以使用join查询</li>
<li>不能使用被驱动表的索引，只能使用 Block Nested-Loop Join 算法，这样的语句就尽量不要使用；</li>
<li>在使用 join 的时候，应该让小表做驱动表。</li>
</ol>
<h3 id="7-数据库隔离级别-amp-amp-可重复读解决了什么问题"><a href="#7-数据库隔离级别-amp-amp-可重复读解决了什么问题" class="headerlink" title="7. 数据库隔离级别 &amp;&amp; 可重复读解决了什么问题"></a>7. 数据库隔离级别 &amp;&amp; 可重复读解决了什么问题</h3><ul>
<li>读未提交： 所有事务都可以看到其他未提交事务的执行结果，脏读</li>
<li>读提交： 事务提交后， 执行结果才能被其他事务看到，不可重复读</li>
<li>可重复读： 一个事务在执行过程中多次读取的结果是一样的。 </li>
<li>串行化： 所有事务串行执行。</li>
</ul>
<p><em>可重复读解决了同一事务中， 两次select读取结果不一致的问题， 使用多版本并发控制解决这种问题。</em></p>
<h3 id="8-幻读"><a href="#8-幻读" class="headerlink" title="8. 幻读"></a>8. 幻读</h3><ol>
<li>在可重复读隔离级别下, 普通的查询是快照读, 是不会看到别的事务插入的数据的. 因此幻读在’当前读’下才会出现 </li>
<li>幻读指的是一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行。幻读专指新插入的行.</li>
</ol>
<p><em>当前读： 读取的数据库记录是最新的， 并且加上锁保证数据不会被其他事务修改</em><br><em>使用next-lock-key， 解决幻读的问题。</em></p>
<h4 id="8-1-next-key-lock"><a href="#8-1-next-key-lock" class="headerlink" title="8.1 next-key lock"></a>8.1 next-key lock</h4><p>间隙锁和行锁共同构成next-key lock</p>
<ul>
<li>原则1：加锁的基本单位是 next-key lock。next-key lock 是前开后闭区间。</li>
<li>原则2：查找过程中访问到的对象才会加锁。</li>
<li>优化1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。</li>
<li>优化2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁。</li>
<li>一个 bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。</li>
</ul>
<h3 id="9-脏读"><a href="#9-脏读" class="headerlink" title="9. 脏读"></a>9. 脏读</h3><p>脏读指的是一个事务还没有提交，修改的数据就可以被其他事务看到。</p>
<h3 id="10-数据库四大特性"><a href="#10-数据库四大特性" class="headerlink" title="10. 数据库四大特性"></a>10. 数据库四大特性</h3><ul>
<li>原子性：一个事务是不可分割的一部分， 事务中的操作要么都执行， 要么都不执行 (undo log)</li>
<li>一致性：一致性是指在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。这是说数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。 (redo log 和 binlog, 两阶段提交)</li>
<li>隔离性：多个事务并发访问时， 事务之间是隔离的， 互不影响 (next-key-lock/MVCC等)</li>
<li>持久性：一旦事务提交， 数据就不可能丢失(redo log 和 binlog, 两阶段提交)</li>
</ul>
<h3 id="11-怎么分库分表"><a href="#11-怎么分库分表" class="headerlink" title="11. 怎么分库分表"></a>11. 怎么分库分表</h3><h3 id="12-分布式事务"><a href="#12-分布式事务" class="headerlink" title="12. 分布式事务"></a>12. 分布式事务</h3>
          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/02/13/面试汇总-数据结构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="flyfish">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/default.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="flyfish's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2021/02/13/面试汇总-数据结构/" class="post-title-link" itemprop="http://yoursite.com/index.html">面试汇总-数据结构</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2021-02-13 15:12:54" itemprop="dateCreated datePublished" datetime="2021-02-13T15:12:54+08:00">2021-02-13</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-02-27 10:22:10" itemprop="dateModified" datetime="2021-02-27T10:22:10+08:00">2021-02-27</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/面试/" itemprop="url" rel="index"><span itemprop="name">面试</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-哈希索引和B-树索引的区别"><a href="#1-哈希索引和B-树索引的区别" class="headerlink" title="1. 哈希索引和B+树索引的区别"></a>1. 哈希索引和B+树索引的区别</h3><ul>
<li>等值查询, 哈希索引具有明显的优势, 范围查询, 哈希索引就用不上</li>
<li>哈希索引不能使用索引进行排序</li>
<li>哈希索引不支持多列联合索引最左前缀匹配原则</li>
<li>大量重复键值的情况下, 哈希索引的效率会比较低, 因为会出现大量的碰撞</li>
</ul>
<h3 id="2-B和B-树的区别"><a href="#2-B和B-树的区别" class="headerlink" title="2. B和B+树的区别"></a>2. B和B+树的区别</h3><ol>
<li>B树所有节点均存储数据和key, B+树只有叶子节点才存储数据, B+树必须要查询到叶子节点, B树不用. </li>
<li>B+树叶子节点都使用指针进行链接, 而B树没有, 所以B树更适用于范围查询</li>
<li>中间节点不存储数据, 磁盘页可以存储更多的数据, 更加的矮胖</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/30/面试汇总-消息队列/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="flyfish">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/default.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="flyfish's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2021/01/30/面试汇总-消息队列/" class="post-title-link" itemprop="http://yoursite.com/index.html">面试汇总-消息队列(RocketMQ为主)</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2021-01-30 10:26:17" itemprop="dateCreated datePublished" datetime="2021-01-30T10:26:17+08:00">2021-01-30</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-02-16 17:21:39" itemprop="dateModified" datetime="2021-02-16T17:21:39+08:00">2021-02-16</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/消息队列/" itemprop="url" rel="index"><span itemprop="name">消息队列</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-消息队列对比"><a href="#1-消息队列对比" class="headerlink" title="1. 消息队列对比"></a>1. 消息队列对比</h3><table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">RocketMQ</th>
<th style="text-align:left">Kafka</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">单机吞吐量</td>
<td style="text-align:left">10w级别</td>
<td style="text-align:left">10w级别</td>
</tr>
<tr>
<td style="text-align:left">topic对吞吐量的影响</td>
<td style="text-align:left">topic可以达到几百、几千个的级别，吞吐量会有小幅度的下降。这是RocketMQ的一大优势，可在同等数量机器下支撑大量的topic</td>
<td style="text-align:left">topic从几十个到几百个的时候，吞吐量会大幅下降。所以在同等机器数量下，kafka尽量保证topic数量不要过多。如果支撑大规模topic需要增加更多的机器</td>
</tr>
<tr>
<td style="text-align:left">时效性</td>
<td style="text-align:left">ms级别</td>
<td style="text-align:left">ms级别</td>
</tr>
<tr>
<td style="text-align:left">可用性</td>
<td style="text-align:left">非常高，分布式架构</td>
<td style="text-align:left">非常高，kafka是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td>
</tr>
<tr>
<td style="text-align:left">消息可靠性</td>
<td style="text-align:left">经过参数优化配置，可以做到0丢失</td>
<td style="text-align:left">经过参数优化配置，可以做到0丢失</td>
</tr>
<tr>
<td style="text-align:left">优势</td>
<td style="text-align:left">接口简单易用，阿里出品有保障，吞吐量大，分布式扩展方便、社区比较活跃，支持大规模的topic、支持复杂的业务场景，可以基于源码进行定制开发</td>
<td style="text-align:left">超高吞吐量，ms级的时延，极高的可用性和可靠性，分布式扩展方便</td>
</tr>
<tr>
<td style="text-align:left">劣势</td>
<td style="text-align:left">接口不是按照标准JMS规范走的，有的系统迁移要修改大量的代码，技术有被抛弃的风险</td>
<td style="text-align:left">有可能进行消息的重复消费</td>
</tr>
<tr>
<td style="text-align:left">应用</td>
<td style="text-align:left">用于大规模吞吐、复杂业务中</td>
<td style="text-align:left">在大数据的实时计算和日志采集中被大规模使用，是业界的标准</td>
</tr>
</tbody>
</table>
<h3 id="2-RocketMQ基本概念"><a href="#2-RocketMQ基本概念" class="headerlink" title="2. RocketMQ基本概念"></a>2. RocketMQ基本概念</h3><ul>
<li>Producer：消息生产者，负责生产消息，一般由业务系统负责生产消息，消息生产者把业务应用例产生的消息发送到broker服务器，</li>
<li>Consumer：消息消费者，从broker服务器拉取消息或者接收broker推送的消息进行消费处理。</li>
<li>Broker：消息中转的角色，负责存储消息、转发消息。</li>
<li>Name Server：充当路由消息的提供者，生产者或消费者可以通过名字查找所需broker的IP列表，集群部署的时候，各个NameServer实例是相互独立的，没有信息交换。主要存储路由信息,broker信息</li>
<li>Topic：表示一类消息的集合，是RocketMQ进行消息订阅的基本单位。</li>
<li>Message Queue：用于存储消息的物理地址，每个Topic中是消息地址存储于多个Message Queue中。</li>
<li>Message：消息系统锁传输信息的物理载体，生产和消费数据的最小单位，每条消息必须属于一个主题。</li>
</ul>
<h3 id="3-为什么需要消息队列-消息队列的优点"><a href="#3-为什么需要消息队列-消息队列的优点" class="headerlink" title="3. 为什么需要消息队列? (消息队列的优点)"></a>3. 为什么需要消息队列? (消息队列的优点)</h3><ul>
<li>异步处理</li>
<li>服务解耦</li>
<li>流量控制</li>
</ul>
<h4 id="3-1-消息队列带来的问题"><a href="#3-1-消息队列带来的问题" class="headerlink" title="3.1 消息队列带来的问题"></a>3.1 消息队列带来的问题</h4><ul>
<li>系统复杂性变高</li>
<li>系统可用性变低, 稳定性受到消息队列稳定性影响</li>
<li>一致性问题</li>
</ul>
<h3 id="4-怎么保证消息不丢失"><a href="#4-怎么保证消息不丢失" class="headerlink" title="4. 怎么保证消息不丢失"></a>4. 怎么保证消息不丢失</h3><ol>
<li>生产者: 处理好Broker的响应, 出错情况下重试, 报警 (另外同步条件下, Producer发送失败会重试两次, 同步模式会换一个broker, 异步模式还是在原来的broker. ❓)</li>
<li>消费者: 执行完真正的业务逻辑之后再返回响应给broker</li>
<li>Broker: 控制返回success的时机, 单机时消息刷盘后返回响应, 集群多副本情况下, 发送两个以上副本的情况下再返回响应. </li>
</ol>
<ul>
<li>消息可靠性增强带来的是性能的下降. 在实际的业务场景中进行取舍. </li>
</ul>
<h3 id="5-怎么保证消息不会重复"><a href="#5-怎么保证消息不会重复" class="headerlink" title="5. 怎么保证消息不会重复"></a>5. 怎么保证消息不会重复</h3><ul>
<li>消息重复的场景: <ul>
<li>消费者没成功发送确认消费的响应.</li>
<li>生产者生产消息后, 由于网络等问题, Broker没有正常的返回success, 但实际上消息已经写入. </li>
</ul>
</li>
</ul>
<ul>
<li>为每个消息分配一个ID. 避免消息重复消费的场景.</li>
</ul>
<h3 id="6-怎么保证消息的有序性"><a href="#6-怎么保证消息的有序性" class="headerlink" title="6. 怎么保证消息的有序性"></a>6. 怎么保证消息的有序性</h3><ul>
<li>全局有序: 只有一个生产者, Topic内部只有一个队列, 只有一个消费者单线程处理</li>
<li>部分有序: 将Topic内部划分为我们需要的队列数, 将消息通过特定的策略发往固定的队列. </li>
</ul>
<h3 id="7-如何处理消息堆积"><a href="#7-如何处理消息堆积" class="headerlink" title="7. 如何处理消息堆积"></a>7. 如何处理消息堆积</h3><ol>
<li>定位消费慢的原因</li>
<li>优化消费逻辑</li>
<li>水平扩容, 增加Topic队列数和消费者数量. </li>
</ol>
<h3 id="8-RocketMQ的消费模式有哪些"><a href="#8-RocketMQ的消费模式有哪些" class="headerlink" title="8. RocketMQ的消费模式有哪些"></a>8. RocketMQ的消费模式有哪些</h3><ol>
<li>集群消费<ul>
<li>一条消息只会被同Group中的一个Consumer消费</li>
<li>多个Group同时消费一个Topic时，每个Group都会有一个Consumer消费到数据</li>
</ul>
</li>
<li>广播消费<ul>
<li>消息将对一个Consumer Group 下的各个 Consumer 实例都消费一遍。即即使这些 Consumer 属于同一个Consumer Group ，消息也会被Consumer Group 中的每个 Consumer 都消费一次。</li>
</ul>
</li>
</ol>
<h3 id="9-RocketMQ的消息存储"><a href="#9-RocketMQ的消息存储" class="headerlink" title="9. RocketMQ的消息存储"></a>9. RocketMQ的消息存储</h3><blockquote>
<p>该部分内容摘抄自<a href="https://zhuanlan.zhihu.com/p/92125985" target="_blank" rel="noopener">RocketMQ消息存储</a></p>
</blockquote>
<h4 id="1-CommitLog"><a href="#1-CommitLog" class="headerlink" title="1. CommitLog"></a>1. CommitLog</h4><ul>
<li>所有的消息存储到CommitLog文件中</li>
<li>以磁盘顺序IO的方式进行写入, 减少IO争用, 提升数据存储的性能</li>
<li>默认最大1G, 超出最大限制自动轮换到下一个文件</li>
<li>包含消息体的长度, CRC校验, queueId, 创建时间, 消息等等等.</li>
</ul>
<h4 id="2-ConsumeQueue"><a href="#2-ConsumeQueue" class="headerlink" title="2. ConsumeQueue"></a>2. ConsumeQueue</h4><ul>
<li>仅存储队列中消息<code>在CommitLog中的偏移量</code>, <code>消息大小</code>, 以及<code>tag的hash值</code>(tagCode)</li>
<li>消费消息的时候, 先读取ConsumeQueue, 再读取CommitLog</li>
</ul>
<h4 id="3-消息存储方式"><a href="#3-消息存储方式" class="headerlink" title="3. 消息存储方式"></a>3. 消息存储方式</h4><p><img src="/2021/01/30/面试汇总-消息队列/./v2-37405d3fe979e8f39bceb88b7ca8638c_1440w.jpg" alt="enter image description here"></p>
<h4 id="4-在消息存储上与kafka的区别"><a href="#4-在消息存储上与kafka的区别" class="headerlink" title="4. 在消息存储上与kafka的区别"></a>4. 在消息存储上与kafka的区别</h4><blockquote>
<p>在消息的存储上，RocketMQ与Kafka的主要区别在于，RocketMQ将所有消息存储在同一个CommitLog中且ConsumeQueue中每个消息只存储20个字节的消息位置信息，而Kafka将每个partition的消息分开存储，这导致RocketMQ单个broker能支持更多的topic和partition。<br>因为在RocketMQ中，所有消息都存储在同一个文件中，这使得RocketMQ的消息存储是磁盘的顺序写，而kafka将消息按partition存储在不同的文件中，因此kafka在消息存储上是随机IO，磁盘的顺序IO要比随机IO快得多，顺序IO可以接近内存的速度。将partition的数量非常大时，kafka中的随机IO将非常多，这将导致kafka在所有topic的partition变大了之后broker性能会明显下降。<br>但是RocketMQ的ConsumeQueue也是随机IO，为何相比kafka能支持更多的partition呢，原因是RocketMQ通过MappedFile的方式读写ConsumeQueue，操作系统对内存映射文件有page cache而ConsumeQueue中的数据都非常小（只有20bytes），读写几乎都是page cache的操作，因此虽然是随机IO但效率也非常高。</p>
</blockquote>
<h3 id="10-RocketMQ容灾和备份"><a href="#10-RocketMQ容灾和备份" class="headerlink" title="10. RocketMQ容灾和备份"></a>10. RocketMQ容灾和备份</h3><blockquote>
<p>RocketMQ 提供消息同步刷盘和异步刷盘两个选择<br>同步刷盘可靠性最高, 但是性能不好.<br>异步刷盘有丢失消息的可能, 可以使用副本机制. </p>
</blockquote>
<h3 id="11-Consume消费消息的重试"><a href="#11-Consume消费消息的重试" class="headerlink" title="11. Consume消费消息的重试"></a>11. Consume消费消息的重试</h3><p><img src="/2021/01/30/面试汇总-消息队列/./6D2BDC7F-033C-433E-9E19-67C4656D4E77.png" alt="enter image description here"></p>
<h3 id="12-RocketMQ订阅关系一致性"><a href="#12-RocketMQ订阅关系一致性" class="headerlink" title="12. RocketMQ订阅关系一致性"></a>12. RocketMQ订阅关系一致性</h3><blockquote>
<p>订阅关系一致指的是同一个消费者Group ID下所有Consumer实例所订阅的Topic、Group ID、Tag必须完全一致。一旦订阅关系不一致，消息消费的逻辑就会混乱，甚至导致消息丢失。</p>
</blockquote>
<h4 id="12-1-为什么要保障RocketMQ订阅关系一致性"><a href="#12-1-为什么要保障RocketMQ订阅关系一致性" class="headerlink" title="12.1 为什么要保障RocketMQ订阅关系一致性"></a>12.1 为什么要保障RocketMQ订阅关系一致性</h4><blockquote>
<p>因为消费者启动时, 将自身的信息注册到服务端. 订阅信息中是以group_id做的key, 其他信息做的value. 多台机器订阅关系不一致会导致订阅信息覆盖. 另一台机器收不到消息的情况. </p>
</blockquote>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/19/面试汇总-Redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="flyfish">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/default.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="flyfish's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2021/01/19/面试汇总-Redis/" class="post-title-link" itemprop="http://yoursite.com/index.html">面试汇总-Redis</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2021-01-19 08:59:28" itemprop="dateCreated datePublished" datetime="2021-01-19T08:59:28+08:00">2021-01-19</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-03-01 08:58:32" itemprop="dateModified" datetime="2021-03-01T08:58:32+08:00">2021-03-01</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/面试/" itemprop="url" rel="index"><span itemprop="name">面试</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Redis-知识点"><a href="#Redis-知识点" class="headerlink" title="Redis 知识点"></a>Redis 知识点</h1><h2 id="一-数据结构"><a href="#一-数据结构" class="headerlink" title="一. 数据结构"></a>一. 数据结构</h2><h3 id="1-简单动态字符串"><a href="#1-简单动态字符串" class="headerlink" title="1. 简单动态字符串"></a>1. 简单动态字符串</h3><ol>
<li>常数复杂度获取字符串长度</li>
<li>杜绝缓冲区溢出</li>
<li>减少修改字符串时带来的内存重分配次数<ul>
<li>空间预分配: 在需要扩容的条件下，如果内容长度小于1M，那么空闲空间的长度等于内容长度，否则，空闲空间的长度为1M</li>
<li>惰性空间释放: 通过API释放空间</li>
</ul>
</li>
<li>二进制安全</li>
<li>兼容部分C字符串函数</li>
</ol>
<h3 id="2-链表"><a href="#2-链表" class="headerlink" title="2. 链表"></a>2. 链表</h3><ol>
<li>双端：链表节点带有prev和next指针，获取某个节点的前置节点和后置节点的复杂度都是O（1）。</li>
<li>无环：表头节点的prev指针和表尾节点的next指针都指向NULL，对链表的访问以NULL为终点。</li>
<li>带表头指针和表尾指针：通过list结构的head指针和tail指针，程序获取链表的表头节点和表尾节点的复杂度为O（1）。</li>
<li>带链表长度计数器：程序使用list结构的len属性来对list持有的链表节点进行计数，程序获取链表中节点数量的复杂度为O（1）。</li>
<li>多态：链表节点使用void*指针来保存节点值，并且可以通过list结构的dup、free、match三个属性为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值。</li>
</ol>
<h3 id="3-字典"><a href="#3-字典" class="headerlink" title="3. 字典"></a>3. 字典</h3><blockquote>
<p>当一个哈希键包含的键值对比较多，又或者键值对中的元素都是比较长的字符串时，Redis就会使用字典作为哈希键的底层实现。<br>负载因子: 元素数量/桶数量</p>
</blockquote>
<p>哈希表执行rehash的步骤如下：</p>
<ol>
<li>为字典的ht<a href="https://mp.weixin.qq.com/s?__biz=MzAxMjgyMTY1NA==&amp;mid=401601934&amp;idx=1&amp;sn=f87768708cdfe54fb6c302f203f3af44#rd" target="_blank" rel="noopener">1</a>哈希表分配空间，这个哈希表的空间大小取决于要执行的操作，以及ht[0]当前包含的键值对数量（也即是ht[0].used属性的值）：<ul>
<li>如果执行的是扩展操作，那么ht<a href="https://mp.weixin.qq.com/s?__biz=MzAxMjgyMTY1NA==&amp;mid=401601934&amp;idx=1&amp;sn=f87768708cdfe54fb6c302f203f3af44#rd" target="_blank" rel="noopener">1</a>的大小为第一个大于等于ht[0].used*2的2 n（2的n次方幂）;</li>
<li>如果执行的是收缩操作，那么ht<a href="https://mp.weixin.qq.com/s?__biz=MzAxMjgyMTY1NA==&amp;mid=401601934&amp;idx=1&amp;sn=f87768708cdfe54fb6c302f203f3af44#rd" target="_blank" rel="noopener">1</a>的大小为第一个大于等于ht[0].used的2 n。</li>
</ul>
</li>
<li>将保存在ht[0]中的所有键值对rehash到ht<a href="https://mp.weixin.qq.com/s?__biz=MzAxMjgyMTY1NA==&amp;mid=401601934&amp;idx=1&amp;sn=f87768708cdfe54fb6c302f203f3af44#rd" target="_blank" rel="noopener">1</a>上面：rehash指的是重新计算键的哈希值和索引值，然后将键值对放置到ht<a href="https://mp.weixin.qq.com/s?__biz=MzAxMjgyMTY1NA==&amp;mid=401601934&amp;idx=1&amp;sn=f87768708cdfe54fb6c302f203f3af44#rd" target="_blank" rel="noopener">1</a>哈希表的指定位置上。</li>
<li>当ht[0]包含的所有键值对都迁移到了ht<a href="https://mp.weixin.qq.com/s?__biz=MzAxMjgyMTY1NA==&amp;mid=401601934&amp;idx=1&amp;sn=f87768708cdfe54fb6c302f203f3af44#rd" target="_blank" rel="noopener">1</a>之后（ht[0]变为空表），释放ht[0]，将ht<a href="https://mp.weixin.qq.com/s?__biz=MzAxMjgyMTY1NA==&amp;mid=401601934&amp;idx=1&amp;sn=f87768708cdfe54fb6c302f203f3af44#rd" target="_blank" rel="noopener">1</a>设置为ht[0]，并在ht<a href="https://mp.weixin.qq.com/s?__biz=MzAxMjgyMTY1NA==&amp;mid=401601934&amp;idx=1&amp;sn=f87768708cdfe54fb6c302f203f3af44#rd" target="_blank" rel="noopener">1</a>新创建一个空白哈希表，为下一次rehash做准备。</li>
</ol>
<p>扩展的条件: </p>
<ol>
<li>服务器目前没有在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于<code>1</code>。</li>
<li>服务器目前正在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于<code>5</code>。</li>
</ol>
<p>收缩的条件: </p>
<ul>
<li>当哈希表的负载因子小于<code>0.1</code>时，程序自动开始对哈希表执行收缩操作。</li>
</ul>
<p>渐进式rehash: 每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定的操作以外，还会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht<a href="https://mp.weixin.qq.com/s?__biz=MzAxMjgyMTY1NA==&amp;mid=401601934&amp;idx=1&amp;sn=f87768708cdfe54fb6c302f203f3af44#rd" target="_blank" rel="noopener">1</a></p>
<h3 id="4-跳跃表"><a href="#4-跳跃表" class="headerlink" title="4. 跳跃表"></a>4. 跳跃表</h3><blockquote>
<p>每个节点由<code>元素</code>, <code>分数</code>, <code>指向上一个节点的指针</code>, <code>各个层</code>组成</p>
</blockquote>
<ol>
<li>新增:</li>
<li>删除:</li>
<li>查找: </li>
</ol>
<h3 id="5-整数集合"><a href="#5-整数集合" class="headerlink" title="5. 整数集合"></a>5. 整数集合</h3><blockquote>
<p>包含编码方式, 元素数量, 保存元素的数组等. 其中元素从小到达有序排列.<br>其中插入和删除的复杂度都是O(N)</p>
</blockquote>
<p>整数集合的升级: </p>
<ol>
<li>扩容: 根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间。</li>
<li>转换: 将底层数组现有的所有元素都转换成与新元素相同的类型，并将类型转换后的元素放置到正确的位上，而且在放置元素的过程中，需要继续维持底层数组的有序性质不变。</li>
<li>插入: 将新元素添加到底层数组里面</li>
</ol>
<h3 id="6-压缩列表"><a href="#6-压缩列表" class="headerlink" title="6. 压缩列表"></a>6. 压缩列表</h3><blockquote>
<p>特殊编码的连续内存块组成的顺序型数据结构. 查询时的复杂度为O(n)或者O(n^2)</p>
</blockquote>
<ol>
<li>zlbytes: 记录压缩列表占用的总字节数</li>
<li>zltail: 记录尾节点距离首节点的偏移量</li>
<li>zllen: 记录节点数量</li>
<li>entry: 列表节点<ul>
<li>previous_entry_length: 记录压缩列表前一个节点的长度</li>
<li>encoding: 节点的数据类型及长度, 最高两位保存编码, 后面的保存长度</li>
<li>content: 保存节点的值.</li>
</ul>
</li>
<li>zlend: 压缩列表末尾</li>
</ol>
<h2 id="二-对象"><a href="#二-对象" class="headerlink" title="二. 对象"></a>二. 对象</h2><h3 id="1-字符串对象"><a href="#1-字符串对象" class="headerlink" title="1. 字符串对象"></a>1. 字符串对象</h3><ul>
<li>整数值, 且可以用long类型来保存, 那么编码为int</li>
<li>字符串值, 长度大于32字节, raw方式, 将使用sds来保存</li>
<li>其他, embstr<ul>
<li>只需要一次内存分配, raw两次(一次sds的, 一次对象的. )</li>
<li>只需要一次内存释放</li>
<li>都保存在一块连续的内存里面, 能更好的利用缓存的优势</li>
</ul>
</li>
</ul>
<p>编码转换: </p>
<ol>
<li>int 升级为 raw</li>
<li>所有对embstr的修改都会升级为raw</li>
</ol>
<h3 id="2-列表对象"><a href="#2-列表对象" class="headerlink" title="2. 列表对象"></a>2. 列表对象</h3><ul>
<li>压缩列表实现: 所有字符串元素都小于64字节, 元素数量小于512个</li>
<li>链表实现: 其他场景使用链表. </li>
</ul>
<h3 id="3-哈希对象"><a href="#3-哈希对象" class="headerlink" title="3. 哈希对象"></a>3. 哈希对象</h3><ul>
<li>压缩列表实现: 先将保存了键的压缩列表节点推入到压缩列表尾, 再将保存了值的压缩列表节点推入压缩列表尾.<ul>
<li>所有键值对的键和值的字符串长度都小于64字节</li>
<li>哈希对象保存的键值对数量小于512个.</li>
</ul>
</li>
<li>字典实现: 其他场景都使用字典实现. </li>
</ul>
<h3 id="4-集合对象"><a href="#4-集合对象" class="headerlink" title="4. 集合对象"></a>4. 集合对象</h3><ul>
<li>整数集合实现<ul>
<li>都是整数值</li>
<li>元素个数小于512个</li>
</ul>
</li>
<li>hashtable实现</li>
</ul>
<h3 id="5-有序集合对象"><a href="#5-有序集合对象" class="headerlink" title="5. 有序集合对象"></a>5. 有序集合对象</h3><ul>
<li>压缩列表实现<ul>
<li>均小于64字节</li>
<li>元素个数小于128个.</li>
</ul>
</li>
<li>跳跃表实现: 同时使用字典和跳跃表, 同时保留范围操作的优势和单个查询的优势.</li>
</ul>
<h2 id="三-Q-amp-A"><a href="#三-Q-amp-A" class="headerlink" title="三. Q&amp;A"></a>三. Q&amp;A</h2><h3 id="1-为什么Redis使用跳跃表不使用红黑树"><a href="#1-为什么Redis使用跳跃表不使用红黑树" class="headerlink" title="1. 为什么Redis使用跳跃表不使用红黑树"></a>1. 为什么Redis使用跳跃表不使用红黑树</h3><ol>
<li>跳跃表范围查询效率高</li>
<li>实现简单, 更加灵活</li>
</ol>
<h3 id="2-为什么Redis快"><a href="#2-为什么Redis快" class="headerlink" title="2. 为什么Redis快"></a>2. 为什么Redis快</h3><ol>
<li>是内存数据库, 都在内存中进行操作</li>
<li>采用了高效的数据结构</li>
<li>采用了多路复用机制，使其在网络 IO 操作中能并发处理大量的客户端请求，实现高吞吐率</li>
<li>单线程操作, 避免CPU线程切换的代价</li>
</ol>
<h3 id="3-Redis的持久化机制-灾备"><a href="#3-Redis的持久化机制-灾备" class="headerlink" title="3. Redis的持久化机制(灾备)"></a>3. Redis的持久化机制(灾备)</h3><h4 id="3-1-RDB快照持久化"><a href="#3-1-RDB快照持久化" class="headerlink" title="3.1 RDB快照持久化"></a>3.1 RDB快照持久化</h4><p>触发时机如下</p>
<ol>
<li>执行save(阻塞主线程) 或者 bgsave(不阻塞, 利用写时复制技术, 即对某块内容进行写入之前进行拷贝. 然后对拷贝的内容执行快照))。</li>
<li>执行shutdown关闭数据库</li>
<li>配置文件配置的定时保存快照触发</li>
</ol>
<ul>
<li>优点： 性能友好， 恢复更快</li>
<li>缺点： 数据不安全，数据集较大时， 比较消耗CPU和消耗时间</li>
</ul>
<h4 id="3-2-AOF-持久化"><a href="#3-2-AOF-持久化" class="headerlink" title="3.2 AOF 持久化"></a>3.2 AOF 持久化</h4><p>记录数据的变化， 将命令添加到aof文件中。 </p>
<ul>
<li>优点： 数据更安全， 内容可读</li>
<li>缺点： 占用体积大，恢复慢， 对Redis性能有所影响。 (会对下一个操作带来阻塞风险)</li>
</ul>
<p><img src="/2021/01/19/面试汇总-Redis/./72f547f18dbac788c7d11yy167d7ebf8.jpg" alt="enter image description here"></p>
<blockquote>
<p>AOF文件太大, 可以通过AOF重写来解决. 即对同一个key的多个操作进行组合.<br>后台线程操作, 不会阻塞主线程. 并通过两个日志来处理解决新来的请求. </p>
</blockquote>
<h4 id="3-3-AOF混合RDB"><a href="#3-3-AOF混合RDB" class="headerlink" title="3.3 AOF混合RDB"></a>3.3 AOF混合RDB</h4><blockquote>
<p>即两次执行RDB之间记录AOF日志</p>
</blockquote>
<h3 id="4-Redis主从同步"><a href="#4-Redis主从同步" class="headerlink" title="4. Redis主从同步"></a>4. Redis主从同步</h3><h4 id="4-1-策略"><a href="#4-1-策略" class="headerlink" title="4.1 策略"></a>4.1 策略</h4><ol>
<li>初期主库将rdb文件同步给从库</li>
<li>从库清空现有数据, 加载rdb文件</li>
<li>后期主库将命令同步给从库</li>
</ol>
<h4 id="4-2-主-从-从模式分担主库压力"><a href="#4-2-主-从-从模式分担主库压力" class="headerlink" title="4.2 主-从-从模式分担主库压力"></a>4.2 主-从-从模式分担主库压力</h4><p><em>同时带来更高的主从延迟</em><br><em>或许可以考虑新增的从库, 初期同步rdb从从库同步, 后期同步命令从主库同步, 这样新从库启动并稳定后, 延迟会降低</em></p>
<p><img src="/2021/01/19/面试汇总-Redis/./403c2ab725dca8d44439f8994959af45.jpg" alt="enter image description here"></p>
<h3 id="5-Redis哨兵"><a href="#5-Redis哨兵" class="headerlink" title="5. Redis哨兵"></a>5. Redis哨兵</h3><ul>
<li>监控: 使用哨兵集群, 监控主库健康度<ul>
<li>主观下线: 如果哨兵发现主库或从库对 PING 命令的响应超时了，那么，哨兵就会先把它标记为“主观下线”。</li>
<li>客观下线: 只有大多数的哨兵实例，都判断主库已经“主观下线”了，主库才会被标记为“客观下线”</li>
</ul>
</li>
<li>选主: 筛选(排除掉不符合条件的从库), 打分(对剩下的从库进行打分)<ul>
<li>打分规则: 从库优先级, 从库复制进度, 从库 ID 号</li>
</ul>
</li>
<li>通知: 发布/订阅</li>
</ul>
<h3 id="6-Redis扩容"><a href="#6-Redis扩容" class="headerlink" title="6. Redis扩容"></a>6. Redis扩容</h3><ul>
<li>纵向扩展: 升级单个Redis实例的配置. 简单, 但容易阻塞(容量大了之后备份问题), 且受到硬件和成本的限制</li>
<li>横向扩展: 数据拆分为多个Redis切片(切片集群). </li>
</ul>
<h4 id="6-1-数据-实例对应"><a href="#6-1-数据-实例对应" class="headerlink" title="6.1 数据-实例对应"></a>6.1 数据-实例对应</h4><ol>
<li>一个切片集群共有 16384 个哈希槽，这些哈希槽类似于数据分区，每个键值对都会根据它的 key，被映射到一个哈希槽中。</li>
<li>对key进行CRC16, 得到一个16bit的值, 然后<code>%16384</code>得到具体的hash槽</li>
<li>具体的实例可以均分这些哈希槽也可以对每个实例执行哈希槽</li>
</ol>
<h4 id="6-2-客户端定位"><a href="#6-2-客户端定位" class="headerlink" title="6.2 客户端定位"></a>6.2 客户端定位</h4><ol>
<li>建立连接时, 客户端会知道实例和哈希槽的对应关系</li>
<li>迁移时, 通过error(ask/moved)来告知客户端数据变化</li>
</ol>
<h3 id="7-Redis做消息队列"><a href="#7-Redis做消息队列" class="headerlink" title="7. Redis做消息队列"></a>7. Redis做消息队列</h3><p>摘自: <a href="https://mp.weixin.qq.com/s?__biz=MzAxMjgyMTY1NA==&amp;mid=401601934&amp;idx=1&amp;sn=f87768708cdfe54fb6c302f203f3af44#rd" target="_blank" rel="noopener">从Redis谈起（三）—— Redis和消息中间件</a></p>
<p><em>如果对消息安全性要求没那么高, 还是一个轻量级的消息队列解决方案</em></p>
<blockquote>
<ol>
<li>Redis自带的PUB/SUB机制，即发布-订阅模式。这种模式生产者(producer)和消费者(consumer)是1-M的关系，即一条消息会被多个消费者消费，当只有一个消费者时即可以看做一个1-1的消息队列，但这种方式并不适合题主的场景。首先，数据可靠性的无法保障，题主的数据最终需要落库，如果消息丢失、Redis宕机部分数据没有持久化甚至突然的网络抖动都可能带来数据的丢失，应该是无法忍受的。其次，扩展不灵活，没法通过多加consumer来加快消费的进度，如果前端写入数据太多，同步会比较慢，数据不同步的状态越久，风险越大，可以通过channel拆分的方式来解决，虽然不灵活，但可以规避。这种方案更适合于对数据可靠性要求不高，比如一些统计日志打点。</li>
<li>Redis的PUSH/POP机制，利用的Redis的列表(lists)数据结构。比较好的使用模式是，生产者lpush消息，消费者brpop消息，并设定超时时间，可以减少redis的压力。这种方案相对于第一种方案是数据可靠性提高了，只有在Redis宕机且数据没有持久化的情况下丢失数据，可以根据业务通过AOF和缩短持久化间隔来保证很高的可靠性，而且也可以通过多个client来提高消费速度。但相对于专业的消息队列来说，该方案消息的状态过于简单(没有状态)，且没有ack机制，消息取出后消费失败依赖于client记录日志或者重新push到队列里面。</li>
</ol>
</blockquote>
<h3 id="8-Redis的内存淘汰策略"><a href="#8-Redis的内存淘汰策略" class="headerlink" title="8. Redis的内存淘汰策略"></a>8. Redis的内存淘汰策略</h3><ol>
<li>直接返回报错</li>
<li>从所有key中随机淘汰</li>
<li>从设置了过期时间的key中随机淘汰</li>
<li>从所有key中执行lru进行淘汰</li>
<li>从设置了过期时间的key中执行lru进行淘汰</li>
<li>在设置了过期时间的Key中， 按照过期时间进行淘汰</li>
</ol>
<h3 id="9-Redis缓存穿透、击穿、雪崩的区别以及如何规避"><a href="#9-Redis缓存穿透、击穿、雪崩的区别以及如何规避" class="headerlink" title="9. Redis缓存穿透、击穿、雪崩的区别以及如何规避"></a>9. Redis缓存穿透、击穿、雪崩的区别以及如何规避</h3><ul>
<li>穿透：用户请求大量的非法值， 导致每次都无法命中redis，最终流量都打到库中。<ol>
<li>对非法值添加到缓存， 比如null</li>
<li>对请求参数增加校验， 直接拦截掉明显的非法请求。</li>
<li>使用布隆过滤器决定某个值不存在。 </li>
</ol>
</li>
<li>击穿：某个时刻缓存失效导致同时有大量的请求打到数据库。 <ul>
<li>设置热点数据永不过期， 或者访问库之前添加互斥锁</li>
</ul>
</li>
<li>雪崩：大量的缓存同时失效， 导致请求都流向了数据库。 <ol>
<li>设置随机的缓存失效时间</li>
</ol>
</li>
</ul>
<p><em>布隆过滤器: 当一个元素被加入集合时，通过K个散列函数将这个元素映射成一个位数组中的K个点，把它们置为1。检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了：如果这些点有任何一个0，则被检元素一定不在；如果都是1，则被检元素很可能在。这就是布隆过滤器的基本思想。</em></p>
<h3 id="10-脑裂"><a href="#10-脑裂" class="headerlink" title="10. 脑裂"></a>10. 脑裂</h3><blockquote>
<p>在主从集群中, 同时有两个节点, 都可以接受写请求<br>原因: 原主库假故障/网络问题<br>解决: 过半机制/设置最少同步的从库数量和最长确认时间. </p>
</blockquote>
<h3 id="11-Redis的数据丢失"><a href="#11-Redis的数据丢失" class="headerlink" title="11. Redis的数据丢失"></a>11. Redis的数据丢失</h3><ol>
<li>过期 key 被清理。</li>
<li>最大内存不足，导致 Redis 自动清理部分 key 以节省空间。</li>
<li>主库故障后自动重启，从库自动同步。</li>
<li>单独的主备方案，网络不稳定触发哨兵的自动切换主从节点，切换期间会有数据丢失。</li>
</ol>
<h3 id="12-Redis事务"><a href="#12-Redis事务" class="headerlink" title="12. Redis事务"></a>12. Redis事务</h3><h3 id="13-Redis管道"><a href="#13-Redis管道" class="headerlink" title="13. Redis管道"></a>13. Redis管道</h3><h2 id="四-特殊的数据结构和算法"><a href="#四-特殊的数据结构和算法" class="headerlink" title="四. 特殊的数据结构和算法"></a>四. 特殊的数据结构和算法</h2><ol>
<li>bitmap</li>
<li>hyperloglog</li>
<li>geohash</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/10/24/Golang汇编基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="flyfish">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/default.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="flyfish's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/10/24/Golang汇编基础/" class="post-title-link" itemprop="http://yoursite.com/index.html">Golang汇编基础</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-10-24 10:26:15" itemprop="dateCreated datePublished" datetime="2020-10-24T10:26:15+08:00">2020-10-24</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-10-27 08:44:10" itemprop="dateModified" datetime="2020-10-27T08:44:10+08:00">2020-10-27</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Golang/" itemprop="url" rel="index"><span itemprop="name">Golang</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一-寄存器基础"><a href="#一-寄存器基础" class="headerlink" title="一. 寄存器基础."></a>一. 寄存器基础.</h2><blockquote>
<p>寄存器（Register）是中央处理器内用来暂存指令、数据和地址的电脑存储器。寄存器的存贮容量有限，读写速度非常快。在计算机体系结构里，寄存器存储在已知时间点所作计算的中间结果，通过快速地访问数据来加速计算机程序的运行。—-来自Wikipedia.</p>
</blockquote>
<p>16位CPU通用寄存器通常有8个, 分别是: AX, BX, CX, DX, BP, SP, SI, DI<br>32位CPU通用寄存器通常有8个, 分别是: EAX, EBX, ECX, EDX, EBP, ESP, ESI, EDI(E表示Extended) </p>
<h3 id="1-1-数据寄存器-AX-BX-CX-DX"><a href="#1-1-数据寄存器-AX-BX-CX-DX" class="headerlink" title="1.1 数据寄存器 AX, BX, CX, DX"></a>1.1 数据寄存器 AX, BX, CX, DX</h3><p>寄存器<code>AX</code>通常称为累加器, 用于存储计算产生的中间结果, 避免每次计算都要读写内存<br>寄存器<code>BX</code>被称为基地址寄存器, 用于存储指针<br>寄存器<code>CX</code>被称为计数寄存器, 在循环和字符串操作时, 用于控制循环次数.<br>寄存器<code>DX</code>被称为数据寄存器, 在进行乘除运算是, 可以作为默认的操作数参与运算, 也可以存放I/O的端口地址. </p>
<h3 id="1-2-指针寄存器-BP-SP"><a href="#1-2-指针寄存器-BP-SP" class="headerlink" title="1.2 指针寄存器 BP, SP"></a>1.2 指针寄存器 BP, SP</h3><p>寄存器<code>BP</code>被称为基址指针寄存器,<br>寄存器<code>SP</code>被称为堆栈指针寄存器,</p>
<h3 id="1-3-变址寄存器-SI-DI"><a href="#1-3-变址寄存器-SI-DI" class="headerlink" title="1.3 变址寄存器 SI, DI"></a>1.3 变址寄存器 SI, DI</h3><p>寄存器<code>SI</code>被称为源变址寄存器,<br>寄存器<code>DI</code>被称为目的变址寄存器</p>
<h3 id="1-4-AMD寄存器和Plan-9"><a href="#1-4-AMD寄存器和Plan-9" class="headerlink" title="1.4 AMD寄存器和Plan 9"></a>1.4 AMD寄存器和Plan 9</h3><p>AMD结构有16个通用寄存器, 以及许多其他寄存器. 具体参见<a href="https://docs.oracle.com/cd/E19205-01/821-2506/gituv/index.html" target="_blank" rel="noopener">AMD64 寄存器信息</a><br>下面是AMD64位和Plan 9寄存器的对应关系:</p>
<table>
<thead>
<tr>
<th>amd</th>
<th>plan 9</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>rax</td>
<td>ax</td>
<td>为函数调用传递参数 </td>
</tr>
<tr>
<td>rbx</td>
<td>bx</td>
<td>被调用方保存</td>
</tr>
<tr>
<td>rcx</td>
<td>cx</td>
<td>为函数调用传递参数 </td>
</tr>
<tr>
<td>rdx</td>
<td>dx</td>
<td>为函数调用传递参数</td>
</tr>
<tr>
<td>rdi</td>
<td>di</td>
<td>为函数调用传递参数  </td>
</tr>
<tr>
<td>rsi</td>
<td>si</td>
<td>为函数调用传递参数</td>
</tr>
<tr>
<td>rbp</td>
<td>bp</td>
<td>栈管理/帧指针</td>
</tr>
<tr>
<td>rsp</td>
<td>sp</td>
<td>栈管理/栈指针</td>
</tr>
<tr>
<td>r8</td>
<td>r8</td>
<td>为函数调用传递参数 </td>
</tr>
<tr>
<td>r9</td>
<td>r9</td>
<td>为函数调用传递参数 </td>
</tr>
<tr>
<td>r10</td>
<td>r10</td>
<td>临时</td>
</tr>
<tr>
<td>r11</td>
<td>r11</td>
<td>临时</td>
</tr>
<tr>
<td>r12</td>
<td>r12</td>
<td>被调用方保存 </td>
</tr>
<tr>
<td>r13</td>
<td>r13</td>
<td>被调用方保存 </td>
</tr>
<tr>
<td>r14</td>
<td>r14</td>
<td>被调用方保存 </td>
</tr>
<tr>
<td>r15</td>
<td>r15</td>
<td>被调用方保存 </td>
</tr>
</tbody>
</table>
<h3 id="1-5-伪寄存器"><a href="#1-5-伪寄存器" class="headerlink" title="1.5 伪寄存器"></a>1.5 伪寄存器</h3><p>Go 的汇编还引入了 4 个伪寄存器，援引官方文档的描述:</p>
<ul>
<li>FP: 使用形如 symbol+offset(FP) 的方式，引用函数的输入参数。例如 arg0+0(FP)，arg1+8(FP).</li>
<li>PC: 实际上就是在体系结构的知识中常见的pc寄存器，在x86平台下对应ip寄存器，amd64上则是rip。除了个别跳转 之外，手写代码与PC寄存器打交道的情况较少.</li>
<li>SB: 全局静态基指针，一般用来声明函数或全局变量.</li>
<li>SP: plan9 的这个 SP 寄存器指向当前栈帧的局部变量的开始位置，使用形如 symbol+offset(SP) 的方式，引用函数的局部变量。offset 的合法取值是 [-framesize, 0). 与硬件寄存器不同, 手写汇编代码时，如果是 symbol+offset(SP) 形式, 则是伪寄存器, offset(SP) 则表示硬件寄存器<code>SP</code></li>
</ul>
<p>注意: 上述伪寄存器SP和硬件寄存器SP的区分仅应用于代码编写, 对于编译和反编译的结果中的SP, 都是硬件寄存器. </p>
<h2 id="二-变量声明"><a href="#二-变量声明" class="headerlink" title="二. 变量声明"></a>二. 变量声明</h2><p>在汇编里所谓的变量，一般是存储在 .rodata 或者 .data 段中的只读值。对应到应用层的话，就是已初始化过的全局的 const、var、static 变量/常量。</p>
<p>使用 DATA 结合 GLOBL 来定义一个变量。DATA 的用法为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DATA    symbol+offset(SB)/width, value</span><br></pre></td></tr></table></figure>
<p>使用 GLOBL 指令将变量声明为 global，额外接收两个参数，一个是 flag，另一个是变量的总大小。<br>GLOBL 必须跟在 DATA 指令之后，下面是一个定义了多个 readonly 的全局变量的完整例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DATA age+0x00(SB)/4, $18  // forever 18</span><br><span class="line">GLOBL age(SB), RODATA, $4</span><br><span class="line"></span><br><span class="line">DATA pi+0(SB)/8, $3.1415926</span><br><span class="line">GLOBL pi(SB), RODATA, $8</span><br><span class="line"></span><br><span class="line">DATA birthYear+0(SB)/4, $1988</span><br><span class="line">GLOBL birthYear(SB), RODATA, $4</span><br></pre></td></tr></table></figure>
<p>正如之前所说，所有符号在声明时，其 offset 一般都是 0。</p>
<p>有时也可能会想在全局变量中定义数组，或字符串，这时候就需要用上非 0 的 offset 了，例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DATA bio&lt;&gt;+0(SB)/8, $&quot;oh yes i&quot;</span><br><span class="line">DATA bio&lt;&gt;+8(SB)/8, $&quot;am here &quot;</span><br><span class="line">GLOBL bio&lt;&gt;(SB), RODATA, $16</span><br></pre></td></tr></table></figure>
<p><strong>关于<code>&lt;&gt;</code>, 这个标记跟在符号名后面, 表明该全局变量只在当前文件中使用. </strong></p>
<h2 id="三-函数声明"><a href="#三-函数声明" class="headerlink" title="三. 函数声明"></a>三. 函数声明</h2><p><img src="http://ttc-tal.oss-cn-beijing.aliyuncs.com/1603672041/image.png" alt="image.png"></p>
<blockquote>
<p>$0表示该函数栈大小为0byte，计算栈大小时，需要考虑局部变量和本函数内调用其他函数时，需要传参的空间，不含函数返回地址和CALLER BP。 $16表示该函数入参和返回值一共有16byte。当有NOSPLIT标识时，可以不写输入参数、返回值占用的大小（这时候会强行插入CALLER BP）。</p>
</blockquote>
<h3 id="3-1-argsize-计算规则"><a href="#3-1-argsize-计算规则" class="headerlink" title="3.1 argsize 计算规则"></a>3.1 argsize 计算规则</h3><p>argsize 的计算方法是，参数大小求和+返回值大小求和，例如入参是 3 个 int64 类型，返回值是 1 个 int64 类型，那么这里的 argsize = sizeof(int64) * 4。</p>
<p>不过真实世界永远没有我们假设的这么美好，函数参数往往混合了多种类型，还需要考虑内存对齐问题。</p>
<p>如果不确定自己的函数签名需要多大的 argsize，可以通过简单实现一个相同签名的空函数，然后 go tool objdump 来逆向查找应该分配多少空间。</p>
<h3 id="3-2-framesize-计算规则"><a href="#3-2-framesize-计算规则" class="headerlink" title="3.2 framesize 计算规则"></a>3.2 framesize 计算规则</h3><p>函数的 framesize 就稍微复杂一些了，手写代码的 framesize 不需要考虑由编译器插入的 caller BP，要考虑：</p>
<ol>
<li>局部变量，及其每个变量的 size。</li>
<li>在函数中是否有对其它函数调用时，如果有的话，调用时需要将 callee 的参数、返回值考虑在内。虽然 return address(rip)的值也是存储在 caller 的 stack frame 上的，但是这个过程是由 CALL 指令和 RET 指令完成 PC 寄存器的保存和恢复的，在手写汇编时，同样也是不需要考虑这个 PC 寄存器在栈上所需占用的 8 个字节的。</li>
<li>原则上来说，调用函数时只要不把局部变量覆盖掉就可以了。稍微多分配几个字节的 framesize 也不会死。<br>在确保逻辑没有问题的前提下，你愿意覆盖局部变量也没有问题。只要保证进入和退出汇编函数时的 caller 和 callee 能正确拿到返回值就可以。</li>
</ol>
<h3 id="3-3-一些示例"><a href="#3-3-一些示例" class="headerlink" title="3.3 一些示例"></a>3.3 一些示例</h3><p>math.go:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span> // 汇编函数声明</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sub</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span> // 汇编函数声明</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mul</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span> // 汇编函数声明</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(add(<span class="number">10</span>, <span class="number">11</span>))</span><br><span class="line">    fmt.Println(sub(<span class="number">99</span>, <span class="number">15</span>))</span><br><span class="line">    fmt.Println(mul(<span class="number">11</span>, <span class="number">12</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>math.s:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;textflag.h&quot; // 因为我们声明函数用到了 NOSPLIT 这样的 flag，所以需要将 textflag.h 包含进来</span><br><span class="line"></span><br><span class="line">// func add(a, b int) int</span><br><span class="line">TEXT ·add(SB), NOSPLIT, $0-24</span><br><span class="line">    MOVQ a+0(FP), AX // 参数 a</span><br><span class="line">    MOVQ b+8(FP), BX // 参数 b</span><br><span class="line">    ADDQ BX, AX    // AX += BX</span><br><span class="line">    MOVQ AX, ret+16(FP) // 返回</span><br><span class="line">    RET</span><br><span class="line"></span><br><span class="line">// func sub(a, b int) int</span><br><span class="line">TEXT ·sub(SB), NOSPLIT, $0-24</span><br><span class="line">    MOVQ a+0(FP), AX</span><br><span class="line">    MOVQ b+8(FP), BX</span><br><span class="line">    SUBQ BX, AX    // AX -= BX</span><br><span class="line">    MOVQ AX, ret+16(FP)</span><br><span class="line">    RET</span><br><span class="line"></span><br><span class="line">// func mul(a, b int) int</span><br><span class="line">TEXT ·mul(SB), NOSPLIT, $0-24</span><br><span class="line">    MOVQ  a+0(FP), AX</span><br><span class="line">    MOVQ  b+8(FP), BX</span><br><span class="line">    IMULQ BX, AX    // AX *= BX</span><br><span class="line">    MOVQ  AX, ret+16(FP)</span><br><span class="line">    RET</span><br><span class="line">    // 最后一行的空行是必须的，否则可能报 unexpected EOF</span><br></pre></td></tr></table></figure></p>
<h2 id="常见指令"><a href="#常见指令" class="headerlink" title="常见指令"></a>常见指令</h2><table>
<thead>
<tr>
<th>指令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>LEA(Q)</td>
<td>Load effective address——取有效地址，也就是取偏移地址</td>
</tr>
</tbody>
</table>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://xargin.com/plan9-assembly/" target="_blank" rel="noopener">plan9 汇编入门</a><br><a href="https://zhuanlan.zhihu.com/p/56750445" target="_blank" rel="noopener">深入理解plan9汇编&amp;实践</a></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/13/Gin中HTTP请求的链路追踪/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="flyfish">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/default.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="flyfish's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/09/13/Gin中HTTP请求的链路追踪/" class="post-title-link" itemprop="http://yoursite.com/index.html">Gin中HTTP请求的链路追踪</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-09-13 13:54:39" itemprop="dateCreated datePublished" datetime="2020-09-13T13:54:39+08:00">2020-09-13</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-09-17 08:58:48" itemprop="dateModified" datetime="2020-09-17T08:58:48+08:00">2020-09-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Golang/" itemprop="url" rel="index"><span itemprop="name">Golang</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一-监听"><a href="#一-监听" class="headerlink" title="一. 监听"></a>一. 监听</h1><p>Gin的自定义监听逻辑比较简单, 在Golang标准HTTP库上层基本没有进行什么封装, 直接调用<code>http.ListenAndServe</code>进行了监听.<br>对应的源码:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServe</span><span class="params">(addr <span class="keyword">string</span>, handler Handler)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	server := &amp;Server&#123;Addr: addr, Handler: handler&#125;</span><br><span class="line">	<span class="keyword">return</span> server.ListenAndServe()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">ListenAndServe</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> srv.shuttingDown() &#123;</span><br><span class="line">		<span class="keyword">return</span> ErrServerClosed</span><br><span class="line">	&#125;</span><br><span class="line">	addr := srv.Addr</span><br><span class="line">	<span class="keyword">if</span> addr == <span class="string">""</span> &#123;</span><br><span class="line">		addr = <span class="string">":http"</span></span><br><span class="line">	&#125;</span><br><span class="line">	ln, err := net.Listen(<span class="string">"tcp"</span>, addr)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> srv.Serve(ln)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到<code>http.ListenAndServe</code>主要进行以下工作</p>
<ol>
<li>生成监听器(Listen)<ul>
<li>解析监听地址&amp;端口号</li>
<li>获取文件描述符</li>
</ul>
</li>
<li>接受请求(Serve)</li>
</ol>
<h2 id="1-1-生成监听器-Listen"><a href="#1-1-生成监听器-Listen" class="headerlink" title="1.1 生成监听器(Listen)"></a>1.1 生成监听器(Listen)</h2><blockquote>
<p>关键代码: net/sock_posix.go</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// socket returns a network file descriptor that is ready for</span></span><br><span class="line"><span class="comment">// asynchronous I/O using the network poller.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">socket</span><span class="params">(ctx context.Context, net <span class="keyword">string</span>, family, sotype, proto <span class="keyword">int</span>, ipv6only <span class="keyword">bool</span>, laddr, raddr sockaddr, ctrlFn <span class="keyword">func</span>(<span class="keyword">string</span>, <span class="keyword">string</span>, syscall.RawConn)</span> <span class="title">error</span>) <span class="params">(fd *netFD, err error)</span></span> &#123;</span><br><span class="line">    s, err := sysSocket(family, sotype, proto)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err = setDefaultSockopts(s, family, sotype, ipv6only); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        poll.CloseFunc(s)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> fd, err = newFD(s, family, sotype, net); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        poll.CloseFunc(s)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> laddr != <span class="literal">nil</span> &amp;&amp; raddr == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> sotype &#123;</span><br><span class="line">        <span class="keyword">case</span> syscall.SOCK_STREAM, syscall.SOCK_SEQPACKET:</span><br><span class="line">            <span class="keyword">if</span> err := fd.listenStream(laddr, listenerBacklog(), ctrlFn); err != <span class="literal">nil</span> &#123; <span class="comment">// 流监听器</span></span><br><span class="line">                fd.Close()</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> fd, <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">case</span> syscall.SOCK_DGRAM:</span><br><span class="line">            <span class="keyword">if</span> err := fd.listenDatagram(laddr, ctrlFn); err != <span class="literal">nil</span> &#123; <span class="comment">// 数据报监听器</span></span><br><span class="line">                fd.Close()</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> fd, <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := fd.dial(ctx, laddr, raddr, ctrlFn); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fd.Close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fd, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在该函数的第一部分, 进行了系统调用, 创建了一个socket(关于创建套接字等套接字基础知识, 参见<a href="https://docs.oracle.com/cd/E19253-01/819-7052/sockets-87164/index.html" target="_blank" rel="noopener">套接字基础知识</a>), 此时的参数分别为: </p>
<ul>
<li>family: AF_INET6 Internet IPv6 和 IPv4 系列</li>
<li>sotype: syscall.SOCK_STREAM 可靠面向链接字节流-TCP</li>
<li>proto: 缺省0. </li>
</ul>
</blockquote>
<blockquote>
<p>该函数的第二部分, 对套接字设置了默认选项, 注意此时ipv6only=false. (关于套接字选项的相关知识, 参见<a href="https://docs.oracle.com/cd/E19253-01/819-7052/sockets-49/index.html" target="_blank" rel="noopener">套接字选项</a>)</p>
</blockquote>
<blockquote>
<p>接着创建了一个流监听器, 点开<code>listenDatagram</code>, 可以发现, 在函数内部, 进行了<code>syscall.Bind</code>的系统调用来绑定<a href="https://docs.oracle.com/cd/E19253-01/819-7052/sockets-6/index.html" target="_blank" rel="noopener">本地地址</a>, 调用<code>syscall.Listen</code>来设置监听器允许积压量.<br>通过<a href="https://docs.oracle.com/cd/E19253-01/819-7052/sockets-8/index.html" target="_blank" rel="noopener">建立连接</a>的文档——<code>要接收客户机的连接，服务器必须在绑定其套接字之后执行两个步骤。第一步是说明可以排队多少连接请求。第二步接受连接。</code><br>我们可以发现一个疑问, 在socket函数中, 仅仅进行了第一步操作, 也就是调用<code>syscall.Listen</code>来说明可以排队多少连接请求, 但并没有调用<code>syscall.Accept</code>来接受连接. 很简单, 接受连接的系统调用在下一部分: <code>接收请求</code>.</p>
</blockquote>
<blockquote>
<p>那么该函数的最后一部分, fd.dial主要做了什么工作呢? 实际上socket函数不仅用于服务端监听, 也用于客户端主动建立连接. 当服务端进行监听时, 走fd.listenxxxxx的逻辑, 而接着就直接退出该函数. 当客户端监听时, 直接进入fd.dial的逻辑, 进入该函数, 也可以看到, 内部进行了<code>syscall.Connect</code>的系统调用. </p>
</blockquote>
<h2 id="1-2-接受请求-Serve"><a href="#1-2-接受请求-Serve" class="headerlink" title="1.2 接受请求(Serve)"></a>1.2 接受请求(Serve)</h2><p>首先来看一看注释</p>
<pre><code>// Serve accepts incoming connections on the Listener l, creating a
// new service goroutine for each. The service goroutines read requests and
// then call srv.Handler to reply to them.
// 
// Serve通过监听器l来接收进来的请求, 并为每一个请求创建一个协程. 该协程读取请求, 然后调用srv.Handler进行响应
</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">Serve</span><span class="params">(l net.Listener)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">	baseCtx := context.Background()</span><br><span class="line">	<span class="keyword">if</span> srv.BaseContext != <span class="literal">nil</span> &#123;</span><br><span class="line">		baseCtx = srv.BaseContext(origListener)</span><br><span class="line">		<span class="keyword">if</span> baseCtx == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(<span class="string">"BaseContext returned a nil context"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ctx := context.WithValue(baseCtx, ServerContextKey, srv)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		rw, e := l.Accept()</span><br><span class="line">		<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">			...</span><br><span class="line">			<span class="keyword">return</span> e</span><br><span class="line">		&#125;</span><br><span class="line">		connCtx := ctx</span><br><span class="line">		<span class="keyword">if</span> cc := srv.ConnContext; cc != <span class="literal">nil</span> &#123;</span><br><span class="line">			connCtx = cc(connCtx, rw)</span><br><span class="line">			<span class="keyword">if</span> connCtx == <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="built_in">panic</span>(<span class="string">"ConnContext returned nil"</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		tempDelay = <span class="number">0</span></span><br><span class="line">		c := srv.newConn(rw)</span><br><span class="line">		c.setState(c.rwc, StateNew) <span class="comment">// before Serve can return</span></span><br><span class="line">		<span class="keyword">go</span> c.serve(connCtx)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以看到, 在这个函数中, 通过循环去不断的接受连接, 在更底层的地方, <code>l.Accept()</code>也进行了建立连接(<code>syscall.Accept</code>)的系统调用, 并将socket设置为非阻塞型IO, 返回的rw为一个TCP连接<code>TCPConn</code>, 接着新启动一个协程来处理该链接, 然后开始等待下一次<code>新连接</code>的到来. 接着看一下Golang如何处理一个链接</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Serve a new connection.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *conn)</span> <span class="title">serve</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	c.remoteAddr = c.rwc.RemoteAddr().String()</span><br><span class="line">	ctx = context.WithValue(ctx, LocalAddrContextKey, c.rwc.LocalAddr())</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &amp;&amp; err != ErrAbortHandler &#123;</span><br><span class="line">			<span class="keyword">const</span> size = <span class="number">64</span> &lt;&lt; <span class="number">10</span></span><br><span class="line">			buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, size)</span><br><span class="line">			buf = buf[:runtime.Stack(buf, <span class="literal">false</span>)]</span><br><span class="line">			c.server.logf(<span class="string">"http: panic serving %v: %v\n%s"</span>, c.remoteAddr, err, buf)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> !c.hijacked() &#123;</span><br><span class="line">			c.<span class="built_in">close</span>()</span><br><span class="line">			c.setState(c.rwc, StateClosed)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// tls 处理逻辑...</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// HTTP/1.x from here on.</span></span><br><span class="line"></span><br><span class="line">	ctx, cancelCtx := context.WithCancel(ctx)</span><br><span class="line">	c.cancelCtx = cancelCtx</span><br><span class="line">	<span class="keyword">defer</span> cancelCtx()</span><br><span class="line"></span><br><span class="line">	c.r = &amp;connReader&#123;conn: c&#125;</span><br><span class="line">	c.bufr = newBufioReader(c.r)</span><br><span class="line">	c.bufw = newBufioWriterSize(checkConnErrorWriter&#123;c&#125;, <span class="number">4</span>&lt;&lt;<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		w, err := c.readRequest(ctx)</span><br><span class="line">		<span class="keyword">if</span> c.r.remain != c.server.initialReadLimitSize() &#123;</span><br><span class="line">			<span class="comment">// If we read any bytes off the wire, we're active.</span></span><br><span class="line">			c.setState(c.rwc, StateActive)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Expect 100 Continue support</span></span><br><span class="line">		req := w.req</span><br><span class="line">		<span class="keyword">if</span> req.expectsContinue() &#123;</span><br><span class="line">			<span class="keyword">if</span> req.ProtoAtLeast(<span class="number">1</span>, <span class="number">1</span>) &amp;&amp; req.ContentLength != <span class="number">0</span> &#123;</span><br><span class="line">				<span class="comment">// Wrap the Body reader with one that replies on the connection</span></span><br><span class="line">				req.Body = &amp;expectContinueReader&#123;readCloser: req.Body, resp: w&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> req.Header.get(<span class="string">"Expect"</span>) != <span class="string">""</span> &#123;</span><br><span class="line">			w.sendExpectationFailed()</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		c.curReq.Store(w)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> requestBodyRemains(req.Body) &#123;</span><br><span class="line">			registerOnHitEOF(req.Body, w.conn.r.startBackgroundRead)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			w.conn.r.startBackgroundRead()</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		serverHandler&#123;c.server&#125;.ServeHTTP(w, w.req)</span><br><span class="line">		w.cancelCtx()</span><br><span class="line">		<span class="keyword">if</span> c.hijacked() &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		w.finishRequest()</span><br><span class="line">		<span class="keyword">if</span> !w.shouldReuseConnection() &#123;</span><br><span class="line">			<span class="keyword">if</span> w.requestBodyLimitHit || w.closedRequestBodyEarly() &#123;</span><br><span class="line">				c.closeWriteAndWait()</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		c.setState(c.rwc, StateIdle)</span><br><span class="line">		c.curReq.Store((*response)(<span class="literal">nil</span>))</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> !w.conn.server.doKeepAlives() &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> d := c.server.idleTimeout(); d != <span class="number">0</span> &#123;</span><br><span class="line">			c.rwc.SetReadDeadline(time.Now().Add(d))</span><br><span class="line">			<span class="keyword">if</span> _, err := c.bufr.Peek(<span class="number">4</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		c.rwc.SetReadDeadline(time.Time&#123;&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在这段代码中, 有循环读取链接的逻辑. 一开始还有些疑问, Golang不是每次请求都会有一个协程处理吗? 后来查了查, 发现是HTTP的长连接. 确切的说, 并不是每次请求都有一个新的协程去处理, 而是每次新的链接都有一个新的协程处理. 而对于HTTP长连接来说, 多次请求由同一个协程去处理. 然后就有了一次迷糊的过程: </p>
</blockquote>
<h3 id="1-2-1-一次犯迷糊的验证过程"><a href="#1-2-1-一次犯迷糊的验证过程" class="headerlink" title="1.2.1 一次犯迷糊的验证过程"></a>1.2.1 一次犯迷糊的验证过程</h3><blockquote>
<p><img src="/2020/09/13/Gin中HTTP请求的链路追踪/1.png" alt="image.png"><br>因为是HTTP长连接, 所以就想验证下, 然后我用了Postman来请求, 用Goland来打断点debug, 发现每次处理完请求, 都会阻塞在1817行的readRequest那里, 此时相当于等待该链接的下一次请求.<br>后来我换了curl来请求, 然后发现处理完这一次请求之后, 依旧是1817行但是没有阻塞, 返回了EOF的err, </p>
</blockquote>
<h1 id="请求链路"><a href="#请求链路" class="headerlink" title="请求链路"></a>请求链路</h1><h1 id="响应链路"><a href="#响应链路" class="headerlink" title="响应链路"></a>响应链路</h1>
          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/default.png" alt="flyfish">
            
              <p class="site-author-name" itemprop="name">flyfish</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">33</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">9</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">24</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">flyfish</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v6.5.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.5.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.5.0"></script>



  



  










  





  

  

  

  

  

  
  

  

  

  

  

  

  

</body>
</html>
